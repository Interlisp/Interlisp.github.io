{{ define "sidebar" }}{{ end }}
{{ define "main" }}

{{- $tooltip := `<strong>Formats</strong><br>1980<br>&gt;=1980<br>&lt;1990<br>=1980<br>1970 to 1980` -}}

<header class="container-fluid mb-3">
  <div class="row align-items-end g-3">
    <div class="col-lg">
      <h1 class="h3 m-0">{{ or .Params.heading .Title }}</h1>
    </div>
    <div class="col-lg-auto">
      <form class="row row-cols-auto g-2 align-items-center" onsubmit="event.preventDefault();">
        <div class="col">
          <label class="form-label mb-0 small" for="itemTypeFilter">Type</label>
          <select id="itemTypeFilter" class="form-select form-select-sm">
            <option value="all">All</option>
            {{ range $key, $value := .Site.Taxonomies.item_type }}
              <option value="{{ $key }}">{{ $key | title }}</option>
            {{ end }}
          </select>
        </div>
        <div class="col">
          <label class="form-label mb-0 small" for="dateExpr">Filter by Year</label>
          <input id="dateExpr"
            type="text"
            class="form-control form-control-sm"
            placeholder="1980, >=1980, 1970 to 1980"
            inputmode="numeric"
            maxlength="12"
            pattern="^\s*(?:[<>]=?|=)?\s*\d{4}(?:\s+(?:to|between)\s+\d{4})?\s*$"
            aria-invalid="false"
            data-bs-toggle="tooltip"
            data-bs-trigger="focus"
            data-bs-animation="true"
            data-bs-html="true"
            data-bs-title="{{ $tooltip | safeHTMLAttr }}" /> 
        </div>
      </form>
    </div>
  </div>
</header>

<div class="container-fluid">
  {{ .Content }}
  <ul class="list-unstyled" id="bibliographyList">
    {{- $previewWordLimit := 24 -}}
    {{- $pages := .RegularPages -}}
    {{- $pages = sort $pages "Date" "desc" -}}
    {{- $pages = sort $pages "Title" "asc" -}}
    {{ range $pages }}
      {{- $d := .Date -}}
      {{- with .Params.date }}
        {{- $iso := trim . " " -}}
        {{- if and (ne $iso "") (findRE `^\d{4}-\d{2}-\d{2}$` $iso) }}
          {{- $d = time $iso -}}
        {{- end -}}
      {{- end -}}
      {{- $fullDate := $d.Format "2006-01-02" -}}
      {{- $year := $d.Format "2006" -}}
      {{- if eq $year "0001" }}{{- $year = "undated" -}}{{ end -}}

      {{- $types := "" -}}
      {{- with .Params.item_type }}
        {{- if reflect.IsSlice . }}
          {{- $types = delimit (apply . "lower" ".") "," -}}
        {{- else }}
          {{- $types = lower . -}}
        {{- end -}}
      {{- end -}}

      <li class="py-3 border-bottom pub-item"
          id="{{ .File.BaseFileName }}"
          data-type="{{ $types }}"
          data-year="{{ $year }}"
          data-date="{{ if ne $fullDate "0001-01-01" }}{{ $fullDate }}{{ end }}">
        <div class="fw-semibold">
          {{- $rawTitle := or .Params.title .Title -}}
          {{- $rendered := replaceRE "^<p>(.*)</p>$" "$1" $rawTitle | htmlEscape -}}
          <a href="{{ .RelPermalink }}" class="text-decoration-none">{{ $rendered | safeHTML }}</a>
        </div>

        {{- $authors := .Params.authors -}}
        {{- $editors := .Params.editors -}}
        {{- $isPatent := eq .Params.item_type "patent" -}}
        {{- if or $authors $editors }}
          <div class="small text-muted">
            {{- if $authors }}
              {{- if reflect.IsSlice $authors }}
                {{- if $isPatent }}Inventors: {{ end }}{{ delimit $authors "; " "; and " }}
              {{- else }}
                {{- if $isPatent }}Inventor: {{ end }}{{ $authors }}
              {{- end }}
            {{- else }}
              Edited by: {{ if reflect.IsSlice $editors }}{{ delimit $editors "; " "; and " }}{{ else }}{{ $editors }}{{ end }}
            {{- end }}
          </div>
        {{- end }}

        {{- if ne $fullDate "0001-01-01" }}
          <div class="small">
            <time datetime="{{ $fullDate }}">{{ .Params.readabledate }}</time>
          </div>
        {{- end }}

        {{ with .Params.abstract }}
          {{- $plain := . | htmlEscape | replaceRE `\s+` " " -}}
          {{- $previewing := gt (countwords $plain) $previewWordLimit -}}
          {{- if $previewing }}
            {{- $previewWords := split $plain " " | first $previewWordLimit -}}
            <div class="mt-2 small">{{ delimit $previewWords " " | safeHTML }}â€¦</div>
          {{- else }}
            <div class="mt-2 small">{{ replace (. | htmlEscape) "\n" "<br>" | safeHTML }}</div>
          {{- end }}
        {{ end }}
      </li>
    {{ end }}
  </ul>
</div>

<script>
document.addEventListener('DOMContentLoaded', function () {
  // ...existing tooltip init & dismissTooltip...

  const typeSel  = document.getElementById('itemTypeFilter');
  const dateExpr = document.getElementById('dateExpr');
  const items    = Array.from(document.querySelectorAll('#bibliographyList > li'));

  // Init Bootstrap tooltip (uses data-bs-animation="true" for fade)
  let dateTip = null;
  if (window.bootstrap && dateExpr) {
    dateTip = bootstrap.Tooltip.getOrCreateInstance(dateExpr);
  }

  // Fade and permanently hide the tooltip (first time only)
  function fadeTooltipAway() {
    if (!dateExpr || dateExpr.dataset.tipHidden === '1') return;
    if (dateTip) {
      dateTip.hide(); // triggers fade
      setTimeout(() => {
        try { dateTip.dispose(); } catch (_) {}
        // Avoid native tooltip with raw HTML
        dateExpr.removeAttribute('title');
        dateExpr.removeAttribute('data-bs-original-title');
        dateExpr.setAttribute('data-bs-title', '');
      }, 200);
    }
    dateExpr.dataset.tipHidden = '1';
  }

  // Clear invalid UI once user edits (no validation yet)
  function clearInvalidUI() {
    if (dateExpr.classList.contains('is-invalid')) {
      dateExpr.classList.remove('is-invalid');
      dateExpr.setAttribute('aria-invalid', 'false');
    }
  }


  // Validate input: allow only year expressions
  function isValidYearExpr(expr) {
    const s = (expr || '').trim();
    if (!s) return true; // empty is OK
    return (
      /^(\d{4})$/.test(s) ||                              // 1980
      /^([<>]=?|=)\s*\d{4}$/.test(s) ||                   // >=1980, <1990, =1980
      /^(\d{4})\s+(?:to|between)\s+(\d{4})$/i.test(s)     // 1970 to 1980 / 1970 between 1980
    );
  }

  // Build a predicate that compares only years
  function buildPredicate(expr) {
    const s = (expr || '').trim();
    if (!s) return () => true;

    let m = s.match(/^(\d{4})\s+(?:to|between)\s+(\d{4})$/i);
    if (m) {
      const y1 = parseInt(m[1], 10), y2 = parseInt(m[2], 10);
      if (Number.isNaN(y1) || Number.isNaN(y2)) return () => true;
      const lo = Math.min(y1, y2), hi = Math.max(y1, y2);
      return y => y != null && y >= lo && y <= hi;
    }

    m = s.match(/^([<>]=?|=)\s*(\d{4})$/);
    if (m) {
      const op = m[1], y = parseInt(m[2], 10);
      if (Number.isNaN(y)) return () => true;
      return yr => {
        if (yr == null) return false;
        switch (op) {
          case '=':  return yr === y;
          case '>':  return yr >  y;
          case '>=': return yr >= y;
          case '<':  return yr <  y;
          case '<=': return yr <= y;
          default:   return true;
        }
      };
    }

    m = s.match(/^(\d{4})$/);
    if (m) {
      const y = parseInt(m[1], 10);
      return yr => yr != null && yr === y;
    }

    // Invalid -> no date filtering
    return () => true;
  }

    function applyValidation() {
    const valid = isValidYearExpr(dateExpr.value);
    dateExpr.classList.toggle('is-invalid', !valid);
    dateExpr.setAttribute('aria-invalid', valid ? 'false' : 'true');
    return valid;
  }

  // Update: showHide can skip changing validation UI unless triggered by Enter
  function showHide(validateNow = true) {
    const typeVal = (typeSel.value || 'all').toLowerCase();
    const valid = validateNow ? applyValidation() : isValidYearExpr(dateExpr.value);
    const pred = valid ? buildPredicate(dateExpr.value) : (() => true);

    items.forEach(li => {
      const types = (li.dataset.type || '')
        .split(',').map(s => s.trim().toLowerCase()).filter(Boolean);
      const yearAttr = (li.dataset.year || '').toLowerCase();
      const yr = /^\d{4}$/.test(yearAttr) ? parseInt(yearAttr, 10) : null;

      const typeOK = (typeVal === 'all') || types.includes(typeVal);
      const yearOK = pred(yr);
      li.style.display = (typeOK && yearOK) ? '' : 'none';
    });
  }

  // Deep-link support
  const params = new URLSearchParams(window.location.search);
  const qType = (params.get('item_type') || '').toLowerCase();
  if (qType && typeSel.querySelector(`option[value="${qType}"]`)) typeSel.value = qType;
  const qDate = params.get('date');
  if (qDate) dateExpr.value = qDate;

  // Only filter-by-type on change; do not validate date here
  typeSel.addEventListener('change', () => showHide(false));

  // Remove live validation; validate/filter only on Enter (CR)
  // ...remove: dateExpr.addEventListener('input', showHide);
  dateExpr.addEventListener('keydown', e => {
    if (e.key === 'Enter') {
      e.preventDefault();
      showHide(true); // validate and apply
    }
  });
  function clearInvalidUI() {
    if (dateExpr.classList.contains('is-invalid')) {
      dateExpr.classList.remove('is-invalid');
      dateExpr.setAttribute('aria-invalid', 'false');
    }
  }

  // Only filter-by-type on change; do not validate date here
  typeSel.addEventListener('change', () => showHide(false));

  dateExpr.addEventListener('input', () => {
    fadeTooltipAway();
    clearInvalidUI();
  });
  dateExpr.addEventListener('paste', () => setTimeout(() => {
    fadeTooltipAway();
    clearInvalidUI();
  }, 0));

  // Validate/filter on Enter and also fade tooltip if still visible
  dateExpr.addEventListener('keydown', e => {
    if (e.key === 'Enter') {
      e.preventDefault();
      fadeTooltipAway();
      showHide(true);
    }
  });

  showHide(true);
});
</script>

{{ end }}