{{ define "sidebar" }}{{ end }}
{{ define "main" }}

<header class="bib-header">
  <h1 class="bib-title">{{ or .Params.heading .Title }}</h1>

  <div class="bib-filter">
    <label for="itemTypeFilter">Filter by Type:</label>
    <select id="itemTypeFilter">
      <option value="all">All</option>
      {{ range $key, $value := .Site.Taxonomies.item_type }}
        <option value="{{ $key }}">{{ $key | title }}</option>
      {{ end }}
    </select>

    <!-- Date expression filter -->
    <label for="dateExpr" style="margin-left:.75rem;">Date:</label>
    <input id="dateExpr" type="text" placeholder="e.g. 1980, >=1980-01-01, 1970 between 1980"
           style="width:15rem;" />
  </div>
</header>

{{ .Content }}

<style>
  .bib-header {
    display: flex;
    align-items: baseline;
    justify-content: space-between;
    gap: 1rem;
    flex-wrap: wrap;
    margin-bottom: 1rem;
  }
  .bib-title { margin: 0; }
  ul.pub-list { list-style: none; margin: 0; padding: 0; }
  ul.pub-list > li { margin: 0; padding: .75rem 0; border-bottom: 1px solid #e2e2e2; }
  ul.pub-list > li:last-child { border-bottom: none; }
</style>

{{- $previewWordLimit := 24 -}}
{{- $pages := .RegularPages -}}
{{- $pages = sort $pages "Date" "desc" -}}
{{- $pages = sort $pages "Title" "asc" -}}

<ul class="pub-list" id="bibliographyList">
  {{ range $pages }}
    {{- /* Derive date */ -}}
    {{- $d := .Date -}}
    {{- with .Params.date -}}
      {{- $iso := trim . " " -}}
      {{- if and (ne $iso "") (findRE `^\d{4}-\d{2}-\d{2}$` $iso) -}}
        {{- $d = time $iso -}}
      {{- end -}}
    {{- end -}}
    {{- $fullDate := $d.Format "2006-01-02" -}}
    {{- $year := $d.Format "2006" -}}
    {{- if eq $year "0001" -}}{{- $year = "undated" -}}{{- end -}}

    {{- /* item_type terms */ -}}
    {{- $types := "" -}}
    {{- with .Params.item_type -}}
      {{- if reflect.IsSlice . -}}
        {{- $types = delimit (apply . "lower" ".") "," -}}
      {{- else -}}
        {{- $types = lower . -}}
      {{- end -}}
    {{- end -}}

    <li class="pub-item"
        data-type="{{ $types }}"
        data-year="{{ $year }}"
        data-date="{{ if ne $fullDate "0001-01-01" }}{{ $fullDate }}{{ end }}">
      {{- $rawTitle := or .Params.title .Title -}}
      {{- $rendered := replaceRE "^<p>(.*)</p>$" "$1" $rawTitle | htmlEscape -}}
      <a href="{{ .RelPermalink }}"><strong>{{ $rendered | safeHTML }}</strong></a><br>

      {{- /* Authors / editors */ -}}
      {{- $authors := .Params.authors -}}
      {{- $editors := .Params.editors -}}
      {{- $isPatent := eq .Params.item_type "patent" -}}
      {{- if or $authors $editors -}}
        {{- if $authors -}}
          {{- if reflect.IsSlice $authors -}}
            {{- if $isPatent }}Inventors: {{ end }}{{ delimit $authors "; " "; and " }}
          {{- else -}}
            {{- if $isPatent }}Inventor: {{ end }}{{ $authors }}
          {{- end -}}
        {{- else -}}
          Edited by: {{ if reflect.IsSlice $editors }}{{ delimit $editors "; " "; and " }}{{ else }}{{ $editors }}{{ end }}
        {{- end -}}
        <br>
      {{- end -}}

      {{- if ne $fullDate "0001-01-01" -}}
        <time datetime="{{ $fullDate }}">{{ .Params.readabledate }}</time><br>
      {{- end -}}

      {{ with .Params.abstract -}}
        {{- $plain := . | htmlEscape | replaceRE `\s+` " " -}}
        {{- $previewing := gt (countwords $plain) $previewWordLimit -}}
        {{- if $previewing -}}
          {{- $previewWords := split $plain " " | first $previewWordLimit -}}
          {{- $preview := delimit $previewWords " " -}}
          <div>{{ $preview | safeHTML }}â€¦</div><br>
        {{- else -}}
          <div>{{ replace (. | htmlEscape) "\n" "<br>" | safeHTML }}</div><br>
        {{- end -}}
      {{- end -}}
    </li>
  {{ end }}
</ul>

<script>
document.addEventListener('DOMContentLoaded', function () {
  const typeSel  = document.getElementById('itemTypeFilter');
  const dateExpr = document.getElementById('dateExpr');
  const items    = Array.from(document.querySelectorAll('#bibliographyList > li'));

  function parseDate(s, isEnd=false) {
    if (!s) return null;
    // YYYY or YYYY-MM or YYYY-MM-DD
    const m = s.match(/^(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?$/);
    if (!m) return null;
    let [ , Y, M, D ] = m;
    M = M || (isEnd ? '12' : '01');
    D = D || (isEnd ? '31' : '01');
    // Basic clipping
    if (parseInt(M,10) > 12) M = '12';
    if (parseInt(D,10) > 31) D = '31';
    return new Date(`${Y}-${M}-${D}T00:00:00Z`);
  }

  function buildPredicate(expr) {
    expr = (expr || '').trim();
    if (!expr) return () => true;

    // Range: A between B
    let m = expr.match(/^(\d{4}(?:-\d{2}(?:-\d{2})?)?)\s+between\s+(\d{4}(?:-\d{2}(?:-\d{2})?)?)$/i);
    if (m) {
      const start = parseDate(m[1], false);
      const end   = parseDate(m[2], true);
      if (!start || !end) return () => true;
      return d => d && d >= start && d <= end;
    }

    // Comparison: op date
    m = expr.match(/^([<>]=?|=)\s*(\d{4}(?:-\d{2}(?:-\d{2})?)?)$/);
    if (m) {
      const op = m[1];
      const dt = parseDate(m[2], op.startsWith('<')); // end-of-period for <
      if (!dt) return () => true;
      return d => {
        if (!d) return false;
        switch (op) {
          case '=':  return d.getTime() === dt.getTime();
          case '>':  return d > dt;
          case '>=': return d >= dt;
          case '<':  return d < dt;
          case '<=': return d <= dt;
          default: return true;
        }
      };
    }

    // Single date/year
    m = expr.match(/^(\d{4}(?:-\d{2}(?:-\d{2})?)?)$/);
    if (m) {
      const start = parseDate(m[1], false);
      const end   = parseDate(m[1], true);
      if (!start || !end) return () => true;
      return d => d && d >= start && d <= end;
    }

    // Fallback -> no filtering
    return () => true;
  }

  function showHide() {
    const typeVal = (typeSel.value || 'all').toLowerCase();
    const pred = buildPredicate(dateExpr.value);
    items.forEach(li => {
      const types = (li.dataset.type || '')
        .split(',').map(s => s.trim().toLowerCase()).filter(Boolean);
      const dateStr = li.dataset.date;
      const dateObj = dateStr ? new Date(dateStr + 'T00:00:00Z') : null;
      const typeOK = (typeVal === 'all') || types.includes(typeVal);
      const dateOK = pred(dateObj);
      li.style.display = (typeOK && dateOK) ? '' : 'none';
    });
  }

  // Deep link (?item_type=book&date=1970%20between%201980)
  const params = new URLSearchParams(window.location.search);
  const qType = (params.get('item_type') || '').toLowerCase();
  if (qType && typeSel.querySelector(`option[value="${qType}"]`)) typeSel.value = qType;
  const qDate = params.get('date');
  if (qDate) dateExpr.value = qDate;

  typeSel.addEventListener('change', showHide);
  dateExpr.addEventListener('input', showHide);
  showHide();
});
</script>

{{ end }}