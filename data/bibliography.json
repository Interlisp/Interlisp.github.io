{
  "Undated": [
    {
      "id": "9296070/9VAUTPVT",
      "type": "article",
      "title": "1982-Bobrow-Stefik-Data-Object-Pgming.pdf"
    },
    {
      "id": "9296070/EPG3LWQF",
      "type": "article",
      "title": "1986-commonloops-oopsla66.pdf"
    },
    {
      "id": "9296070/2GN25ESU",
      "type": "article",
      "title": "1979-stefik-examination-of-frame-structured.pdf"
    },
    {
      "id": "9296070/7MG5RV9Y",
      "type": "article",
      "title": "1987-Themes-Variations-Stefik-Loops-.pdf"
    },
    {
      "id": "9296070/Z3QZB88Q",
      "type": "article",
      "title": "1986-access-oriented.pdf"
    },
    {
      "id": "9296070/UK4LUYSV",
      "type": "article",
      "title": "CSD-84-215.pdf",
      "URL": "https://digitalassets.lib.berkeley.edu/techreports/ucb/text/CSD-84-215.pdf",
      "accessed": {
        "date-parts": [
          [
            2022,
            12,
            20
          ]
        ]
      }
    },
    {
      "id": "9296070/HI5WIUJQ",
      "type": "article",
      "title": "ED285570.pdf",
      "URL": "https://files.eric.ed.gov/fulltext/ED285570.pdf",
      "accessed": {
        "date-parts": [
          [
            2021,
            8,
            6
          ]
        ]
      }
    },
    {
      "id": "9296070/KFW6YRLW",
      "type": "article",
      "title": "CSL-77-3_A_Display_Oriented_Programmers_Assistant.pdf",
      "URL": "http://bitsavers.trailing-edge.com/pdf/xerox/parc/techReports/CSL-77-3_A_Display_Oriented_Programmers_Assistant.pdf",
      "accessed": {
        "date-parts": [
          [
            2022,
            6,
            15
          ]
        ]
      }
    },
    {
      "id": "9296070/RNYPDS4F",
      "type": "article",
      "title": "CSL-79-6_Raster_Graphics_for_Interactive_Programming_Environments.pdf",
      "URL": "http://bitsavers.trailing-edge.com/pdf/xerox/parc/techReports/CSL-79-6_Raster_Graphics_for_Interactive_Programming_Environments.pdf",
      "accessed": {
        "date-parts": [
          [
            2022,
            6,
            15
          ]
        ]
      }
    },
    {
      "id": "9296070/ZB2TAD4S",
      "type": "article",
      "title": "Xerox_Globalview_Document_Services_for_Sun_Technical_Reference_Manual_Jun92.pdf",
      "URL": "http://www.bitsavers.org/pdf/xerox/xns_services/services_sparc/Xerox_Globalview_Document_Services_for_Sun_Technical_Reference_Manual_Jun92.pdf",
      "accessed": {
        "date-parts": [
          [
            2022,
            7,
            26
          ]
        ]
      }
    },
    {
      "id": "9296070/GSH9NUT6",
      "type": "article",
      "title": "ahc_20150101_jan_2015.pdf",
      "URL": "https://opost.com/tenex/ahc_20150101_jan_2015.pdf",
      "accessed": {
        "date-parts": [
          [
            2022,
            1,
            30
          ]
        ]
      }
    },
    {
      "id": "9296070/RJPVRIGF",
      "type": "post-weblog",
      "title": "Truckin’ and the Knowledge Competitions | MJSBlog",
      "abstract": "MJSBlog - Workin on it",
      "URL": "https://www.markstefik.com/?page_id=359",
      "language": "en-US",
      "accessed": {
        "date-parts": [
          [
            2022,
            7,
            17
          ]
        ]
      }
    },
    {
      "id": "9296070/9LHKWE3T",
      "type": "article-journal",
      "title": "Perspectives on Artificial Intelligence Programming",
      "page": "8",
      "volume": "231",
      "language": "en",
      "author": [
        {
          "family": "Bobrow",
          "given": "G"
        },
        {
          "family": "Stefik",
          "given": "J"
        }
      ]
    },
    {
      "id": "9296070/GZU4TBQ5",
      "type": "article-journal",
      "title": "Perspectives on Artificial Intelligence Programming",
      "page": "8",
      "volume": "231",
      "language": "en",
      "author": [
        {
          "family": "Bobrow",
          "given": "G"
        },
        {
          "family": "Stefik",
          "given": "J"
        }
      ]
    },
    {
      "id": "9296070/CER4PF8K",
      "type": "webpage",
      "title": "NOTES ON XEROX LISP MACH DEMO",
      "URL": "https://ml.cddddr.org/lisp@parc/msg00137.html",
      "accessed": {
        "date-parts": [
          [
            2021,
            9,
            16
          ]
        ]
      }
    },
    {
      "id": "9296070/B63F5Q8E",
      "type": "webpage",
      "title": "Xerox Alto Emulator",
      "URL": "https://archives.loomcom.com/contraltojs/",
      "accessed": {
        "date-parts": [
          [
            2021,
            8,
            20
          ]
        ]
      }
    },
    {
      "id": "9296070/3UNHV59N",
      "type": "webpage",
      "title": "Lisp and Symbolic Computation",
      "container-title": "Table of contents for issues of Lisp and Symbolic Computation",
      "URL": "http://ftp.math.utah.edu/pub/tex/bib/toc/lispsymbcomput.html",
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            25
          ]
        ]
      }
    }
  ],
  "1966": [
    {
      "id": "9296070/LQQWKMEZ",
      "type": "paper-conference",
      "title": "Format-directed list processing in LISP",
      "container-title": "Proceedings of the first ACM symposium on Symbolic and algebraic manipulation",
      "collection-title": "SYMSAC '66",
      "publisher": "Association for Computing Machinery",
      "publisher-place": "New York, NY, USA",
      "page": "0301–0329",
      "event-place": "New York, NY, USA",
      "abstract": "This article describes a notation and a programming language for expressing, from within a LISP system, string transformations such as those performed in COMIT or SNOBOL. A simple transformation (or transformation rule) is specified by providing a pattern which must match the structure to be transformed and a format which specifies how to construct a new structure according to the segmentation specified by the pattern. The patterns and formats are greatly generalized versions of the left-half and right-half rules of COMIT and SNOBOL. For example, elementary patterns and formats can be variable names, results of computations, disjunctive sets, or repeating subpatterns; predicates can be associated with elementary patterns which check relationships among separated elements of the match; it is no longer necessary to restrict the operations to linear strings since elementary patterns can themselves match structures. The FLIP language has been implemented in LISP 1.5, and has been successfully used in such disparate tasks as editing LISP functions and parsing Kleene regular expressions.",
      "URL": "https://doi.org/10.1145/800005.807968",
      "DOI": "10.1145/800005.807968",
      "ISBN": "978-1-4503-7371-5",
      "author": [
        {
          "family": "Bobrow",
          "given": "Daniel G."
        },
        {
          "family": "Teitelman",
          "given": "Warren"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1966",
            1,
            1
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            5,
            31
          ]
        ]
      }
    },
    {
      "id": "9296070/6M8ISEUL",
      "type": "article",
      "title": "Preliminary Specification for BBN 940 LISP",
      "URL": "http://www.softwarepreservation.org/projects/LISP/bbnlisp/BBN940LispPrelimSpec_Oct1966.pdf",
      "language": "English",
      "author": [
        {
          "family": "Daniel G. Bobrow",
          "given": ""
        },
        {
          "family": "Daniel L. Murphy",
          "given": ""
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1966",
            10,
            13
          ]
        ]
      }
    }
  ],
  "1967": [
    {
      "id": "9296070/G796KZSG",
      "type": "article-journal",
      "title": "Structure of a LISP system using two-level storage: Communications of the ACM",
      "container-title": "Communications of the ACM",
      "page": "155-159",
      "volume": "10",
      "issue": "3",
      "abstract": "In an ideal list-processing system there would be enough core memory to contain all the data and programs. Described in this paper are a number of techniques that have been used to build a LISP system utilizing a drum for its principal storage medium, with a surprisingly low time penalty for use of this slow storage device. The techniques include careful segmentation of system programs, allocation of virtual memory to allow address arithmetic for type determination, and a special algorithm for building reasonably linearized lists. A scheme for binding variables is described which is good in this environment and allows for complete compatibility between compiled and interpreted programs with no special declarations.",
      "URL": "https://dl.acm.org/doi/10.1145/363162.363185",
      "DOI": "10.1145/363162.363185",
      "journalAbbreviation": "Commun. ACM",
      "language": "en",
      "author": [
        {
          "family": "Bobrow",
          "given": "Daniel G."
        },
        {
          "family": "Murphy",
          "given": "Daniel L."
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1967"
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            16
          ]
        ]
      }
    },
    {
      "id": "9296070/PGGC8GAZ",
      "type": "article",
      "title": "Recent Improvements to 940 LISP Library",
      "URL": "http://bitsavers.org/pdf/sds/9xx/940/ucbProjectGenie/940_LISP_Memo_2_Apr67.pdf",
      "author": [
        {
          "family": "Teitelman",
          "given": "Warren"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1967",
            4,
            10
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            21
          ]
        ]
      }
    },
    {
      "id": "9296070/LQAA78HI",
      "type": "report",
      "title": "The BBN-LISP System",
      "page": "138",
      "abstract": "This report describes the LISP system implemented at BBN on the \nSDS 940 Computer. This LISP is an upward compatible extension of \nLISP 1.5 for the IBM 7090, with a number of new features which \nmake it work well as an on-line language. These new features \ninclude tracing, and conditional breakpoints in functions for \ndebugging and a sophisticated LISP oriented editor. The BBN 940 \nLISP SYSTEM has a large memory store (approximately 50,000 free \nwords) utilizing special paging techniques for a drum to provide \nreasonable computation times. The system includes both an \ninterpreter, a fully compatible compiler, and an assembly language \nfacility for inserting machine code subroutines.",
      "URL": "http://www.softwarepreservation.org/projects/LISP/bbnlisp/BBN940Lisp_Jul67.pdf/view",
      "number": "9",
      "language": "English",
      "author": [
        {
          "family": "Daniel G. Bobrow",
          "given": ""
        },
        {
          "family": "D. Lucille Darley",
          "given": ""
        },
        {
          "family": "L. Peter Deutsch",
          "given": ""
        },
        {
          "family": "Daniel L. Murphy",
          "given": ""
        },
        {
          "family": "Warren Teitelman",
          "given": ""
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1967",
            7,
            15
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            23
          ]
        ]
      }
    }
  ],
  "1972": [
    {
      "id": "9296070/KP33M4DP",
      "type": "article",
      "title": "BBN - LISP, TENEX Reference Manual, Revised",
      "publisher": "Bolt, Beranek and Newman, Inc. (BBN)",
      "URL": "http://www.bitsavers.org/pdf/bbn/tenex/TenexLispRef_Aug72.pdf",
      "author": [
        {
          "family": "Teitelman",
          "given": "W."
        },
        {
          "family": "Bobrow",
          "given": "D. G."
        },
        {
          "family": "Hartley",
          "given": "A. K."
        },
        {
          "family": "Murphy",
          "given": "D. L."
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1972",
            8
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            6,
            1
          ]
        ]
      }
    },
    {
      "id": "9296070/QWKIX8DW",
      "type": "paper-conference",
      "title": "Automated programmering: the programmer's assistant",
      "container-title": "Proceedings of the December 5-7, 1972, fall joint computer conference, part II",
      "collection-title": "AFIPS '72 (Fall, part II)",
      "publisher": "Association for Computing Machinery",
      "publisher-place": "New York, NY, USA",
      "page": "917–921",
      "event-place": "New York, NY, USA",
      "abstract": "This paper describes a research effort and programming system designed to facilitate the production of programs. Unlike automated programming, which focuses on developing systems that write programs, automated programmering involves developing systems which automate (or at least greatly facilitate) those tasks that a programmer performs other than writing programs: e.g., repairing syntactical errors to get programs to run in the first place, generating test cases, making tentative changes, retesting, undoing changes, reconfiguring, massive edits, et al., plus repairing and recovering from mistakes made during the above. When the system in which the programmer is operating is cooperative and helpful with respect to these activities, the programmer can devote more time and energy to the task of programming itself, i.e., to conceptualizing, designing and implementing. Consequently, he can be more ambitious, and more productive.",
      "URL": "https://doi.org/10.1145/1480083.1480119",
      "DOI": "10.1145/1480083.1480119",
      "ISBN": "978-1-4503-7913-7",
      "shortTitle": "Automated programmering",
      "author": [
        {
          "family": "Teitelman",
          "given": "Warren"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1972",
            12,
            5
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            5,
            31
          ]
        ]
      }
    }
  ],
  "1973": [
    {
      "id": "9296070/EM6WJF9A",
      "type": "article-journal",
      "title": "A model and stack implementation of multiple environments",
      "container-title": "Communications of the ACM",
      "page": "591-603",
      "volume": "16",
      "issue": "10",
      "abstract": "Many control and access environment structures require that storage for a procedure activation exist at times when control is not nested within the procedure activated. This is straightforward to implement by dynamic storage allocation with linked blocks for each activation, but rather expensive in both time and space. This paper presents an implementation technique using a single stack to hold procedure activation storage which allows retention of that storage for durations not necessarily tied to control flow. The technique has the property that, in the simple case, it runs identically to the usual automatic stack allocation and deallocation procedure. Applications of this technique to multitasking, coroutines, backtracking, label-valued variables, and functional arguments are discussed. In the initial model, a single real processor is assumed, and the implementation assumes multiple-processes coordinate by passing control explicitly to one another. A multiprocessor implementation requires only a few changes to the basic technique, as described.",
      "URL": "https://dl.acm.org/doi/10.1145/362375.362379",
      "DOI": "10.1145/362375.362379",
      "journalAbbreviation": "Commun. ACM",
      "language": "en",
      "author": [
        {
          "family": "Bobrow",
          "given": "Daniel G."
        },
        {
          "family": "Wegbreit",
          "given": "Ben"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1973"
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            16
          ]
        ]
      }
    },
    {
      "id": "9296070/NQXP9QH8",
      "type": "paper-conference",
      "title": "A LISP machine with very compact programs",
      "container-title": "Proceedings of the 3rd international joint conference on Artificial intelligence",
      "collection-title": "IJCAI'73",
      "publisher": "Morgan Kaufmann Publishers Inc.",
      "publisher-place": "San Francisco, CA, USA",
      "page": "697–703",
      "event-place": "San Francisco, CA, USA",
      "abstract": "This paper presents a machine designed for compact representation and rapid execution of LISP programs. The machine language is a factor of 2 to 5 more compact than S-expressions or conventional compiled code, and the compiler is extremely simple. The encoding scheme is potentially applicable to data as well as program. The machine also provides for user-defined data structures.",
      "URL": "https://dl.acm.org/doi/abs/10.5555/1624775.1624860",
      "author": [
        {
          "family": "Deutsch",
          "given": "L. Peter"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1973",
            8,
            20
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            5,
            31
          ]
        ]
      }
    },
    {
      "id": "9296070/LSJRVJU8",
      "type": "article-journal",
      "title": "INTERLISP",
      "container-title": "ACM SIGART Bulletin",
      "page": "8-9",
      "issue": "43",
      "abstract": "INTERLISP (INTERactive LISP) is a LISP system currently implemented on the DEC PDP-10 under the BBN TENEX time sharing system<*R1>. INTERLISP is designed to provide the user access to the large virtual memory allowed by TENEX, with a relatively small penalty in speed (using special paging techniques described in <*R2>). Additional data types have been added, including strings, arrays, and hash association tables (hash links). The system includes a compatible compiler and interpreter. Machine code can be intermixed with INTERLISP expressions via the assemble directive of the compiler. The compiler also contains a facility for \"block compilation\" which allows a group of functions to be compiled as a unit, suppressing internal names. Each successive level of computation, from interpreted through compiled, to block-compiled provides greater speed at a cost of debugging ease.",
      "URL": "https://doi.org/10.1145/1056786.1056787",
      "DOI": "10.1145/1056786.1056787",
      "journalAbbreviation": "SIGART Bull.",
      "author": [
        {
          "family": "Teitelman",
          "given": "Warren"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1973",
            12,
            1
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            15
          ]
        ]
      }
    },
    {
      "id": "9296070/I5AH4B95",
      "type": "report",
      "title": "An interactive program verifier",
      "publisher-place": "California",
      "event-place": "California",
      "abstract": "Program verification refers to the idea that the intent or effect of a program can be stated in a precise way that is not a simple \"rewording \" of the program itself, and that one can prove (in the mathematical sense) that a program actually conforms to a given statement of intent. This thesis describes a software system which can verify (prove) some non-trivial programs automatically. The system described here is organized in a novel manner compared to most other theorem-proving systems. IL has a great deal of specific knowledge about integers and arrays of integers, yet it is not \"special-purpose\", since this knowledge is represented in procedures which are separate from the underlying structure of the system. It also incorporates some knowledge, gained by the author from both experiment and introspection, about how programs are often constructed, and uses this knowledge to guide the proof process. It uses its knowledge, plus contextual information from the program being verified, to simplify the theorems dramatically as they are being constructed, rather than relying on a super-powerful proof procedure. The system also provides for interactive editing of programs and assertions, and for detailed human control of the proof process when the system cannot produce a proof (or counter-example) on its own.",
      "URL": "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.696.5498",
      "author": [
        {
          "family": "Deutsch",
          "given": "L. Peter"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1973",
            5
          ]
        ]
      }
    }
  ],
  "1975": [
    {
      "id": "9296070/QFBSW8AZ",
      "type": "article-journal",
      "title": "A note on hash linking",
      "container-title": "Communications of the ACM",
      "page": "413-415",
      "volume": "18",
      "issue": "7",
      "abstract": "In current machine designs, a machine address gives the user direct access to a single piece of information, namely the contents of that machine word. This note is based on the observation that it is often useful to associate additional information, with some (relatively few) address locations determined at run time, without the necessity of preallocating the storage at all possible such addresses. That is, it can be useful to have an effective extra bit, field, or address in some words without every word having to contain a bit (or bits) to mark this as a special case. The key idea is that this extra associated information can be found by a table search. Although it could be found by any search technique (e.g. linear, binary sorted, etc.), we suggest that an appropriate low overhead mechanism is to use hash search on a table in which the key is the address of the cell to be augmented.",
      "URL": "https://dl.acm.org/doi/10.1145/360881.360920",
      "DOI": "10.1145/360881.360920",
      "journalAbbreviation": "Commun. ACM",
      "language": "en",
      "author": [
        {
          "family": "Bobrow",
          "given": "Daniel G."
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1975"
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            16
          ]
        ]
      }
    },
    {
      "id": "9296070/KQM2N5FW",
      "type": "report",
      "title": "PIVOT source listing",
      "publisher-place": "California",
      "event-place": "California",
      "abstract": "Program verification refers to the idea that the intent or effect of a program can be stated in a precise way that is not a simple \"rewording \" of the program itself, and that one can prove (in the mathematical sense) that a program actually conforms to a given statement of intent. This thesis describes a software system which can verify (prove) some non-trivial programs automatically. The system described here is organized in a novel manner compared to most other theorem-proving systems. IL has a great deal of specific knowledge about integers and arrays of integers, yet it is not \"special-purpose\", since this knowledge is represented in procedures which are separate from the underlying structure of the system. It also incorporates some knowledge, gained by the author from both experiment and introspection, about how programs are often constructed, and uses this knowledge to guide the proof process. It uses its knowledge, plus contextual information from the program being verified, to simplify the theorems dramatically as they are being constructed, rather than relying on a super-powerful proof procedure. The system also provides for interactive editing of programs and assertions, and for detailed human control of the proof process when the system cannot produce a proof (or counter-example) on its own.",
      "URL": "http://www.softwarepreservation.org/projects/verification/pivot/Deutsch-Pivot.pdf",
      "author": [
        {
          "family": "Deutsch",
          "given": "L. Peter"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1975",
            3,
            19
          ]
        ]
      }
    },
    {
      "id": "9296070/JP52RFKS",
      "type": "report",
      "title": "Status Report on Alto Lisp",
      "publisher": "PARC/CSL",
      "publisher-place": "Palo Alto",
      "page": "2",
      "event-place": "Palo Alto",
      "URL": "http://www.bitsavers.org/pdf/xerox/alto/memos_1975/Status_Report_on_Alto_Lisp_May75.pdf",
      "shortTitle": "xerox",
      "language": "eng",
      "author": [
        {
          "family": "Deutsch",
          "given": "P."
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1975",
            5,
            14
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            5,
            31
          ]
        ]
      }
    }
  ],
  "1976": [
    {
      "id": "9296070/RAASKHRE",
      "type": "article-journal",
      "title": "An efficient, incremental, automatic garbage collector",
      "container-title": "Communications of the ACM",
      "page": "522-526",
      "volume": "19",
      "issue": "9",
      "abstract": "This paper describes a new way of solving the storage reclamation problem for a system such as Lisp that allocates storage automatically from a heap, and does not require the programmer to give any indication that particular items are no longer useful or accessible. A reference count scheme for reclaiming non-self-referential structures, and a linearizing, compacting, copying scheme to reorganize all storage at the users discretion are proposed. The algorithms are designed to work well in systems which use multiple levels of storage, and large virtual address space. They depend on the fact that most cells are referenced exactly once, and that reference counts need only be accurate when storage is about to be reclaimed. A transaction file stores changes to reference counts, and a multiple reference table stores the count for items which are referenced more than once.",
      "URL": "https://dl.acm.org/doi/10.1145/360336.360345",
      "DOI": "10.1145/360336.360345",
      "journalAbbreviation": "Commun. ACM",
      "language": "en",
      "author": [
        {
          "family": "Deutsch",
          "given": "L. Peter"
        },
        {
          "family": "Bobrow",
          "given": "Daniel G."
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1976"
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            16
          ]
        ]
      }
    },
    {
      "id": "9296070/QBBQSH3V",
      "type": "article-journal",
      "title": "Clisp: Conversational Lisp",
      "container-title": "IEEE Transactions on Computers",
      "page": "354-357",
      "volume": "C-25",
      "issue": "4",
      "abstract": "Clisp is an attempt to make Lisp programs easier to read and write by extending the syntax of Lisp to include infix operators, IF-THEN statements, FOR-DO-WHILE statements, and similar Algol-like constructs, without changing the structure or representation of the language. Clisp is implemented through Lisp's error handling machinery, rather than by modifying the interpreter. When an expression is encountered whose evaluation causes an error, the expression is scanned for possible Clisp constructs, which are then converted to the equivalent Lisp expressions. Thus, users can freely intermix Lisp and Clisp without ut having to distinguish which is which. Emphasis in the design and development of Clisp has been on the system aspects of such a facility, with the goal of producing a useful tool, not just another language. To this end, Clisp includes interactive error correction and many \"do-what-I-mean\" features.",
      "URL": "http://www.softwarepreservation.org/projects/LISP/interlisp/Teitelman-3IJCAI.pdf/view",
      "DOI": "10.1109/TC.1976.1674617",
      "note": "Conference Name: IEEE Transactions on Computers",
      "shortTitle": "Clisp",
      "author": [
        {
          "family": "Teitelman",
          "given": "Warren"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1976",
            4
          ]
        ]
      }
    },
    {
      "id": "9296070/P43BUE35",
      "type": "webpage",
      "title": "PARCMESSAGE.TXT.1.",
      "container-title": "Software Preservation Group",
      "URL": "http://www.softwarepreservation.org/projects/LISP/interlisp/tenex/twenex.org/PARCMESSAGE.TXT.1/view",
      "author": [
        {
          "family": "Masinter",
          "given": "Larry"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1976",
            1
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            23
          ]
        ]
      }
    }
  ],
  "1978": [
    {
      "id": "9296070/QXZFUW4U",
      "type": "article-journal",
      "title": "Experience with a microprogrammed Interlisp system",
      "container-title": "ACM SIGMICRO Newsletter",
      "page": "128–129",
      "volume": "9",
      "issue": "4",
      "abstract": "This paper presents the design of an Interlisp system running on a microprogrammed minicomputer. We discuss the constraints imposed by compatibility requirements and by the hardware, the important design decisions, and the most prominent successes and failures of our design, and offer some suggestions for future designers of small Lisp systems. This extended abstract contains only qualitative results. Supporting measurement data will be presented at MICRO-11.",
      "URL": "https://doi.org/10.1145/1014198.804321",
      "DOI": "10.1145/1014198.804321",
      "journalAbbreviation": "SIGMICRO Newsl.",
      "author": [
        {
          "family": "Deutsch",
          "given": "L. Peter"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1978",
            11,
            19
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            5,
            31
          ]
        ]
      }
    },
    {
      "id": "9296070/JEW9IHTC",
      "type": "article",
      "title": "INSIDE INTERLISP: TWO IMPLEMENTATIONS",
      "publisher": "Xerox Palo Alto Research Center",
      "URL": "http://www.softwarepreservation.org/projects/LISP/interlisp/Deutsch-Inside_Interlisp-1978.pdf",
      "language": "English",
      "author": [
        {
          "family": "Deutsch",
          "given": "L. Peter"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1978",
            11,
            26
          ]
        ]
      }
    }
  ],
  "1979": [
    {
      "id": "9296070/PE98QZ2L",
      "type": "paper-conference",
      "title": "Raster graphics for interactive programming environments",
      "container-title": "Proceedings of the 6th annual conference on Computer graphics and interactive techniques",
      "collection-title": "SIGGRAPH '79",
      "publisher": "Association for Computing Machinery",
      "publisher-place": "New York, NY, USA",
      "page": "83–93",
      "event-place": "New York, NY, USA",
      "abstract": "Raster-scan display terminals can significantly improve the quality of interaction with conventional computer systems. The design of a graphics package to provide a “window” into the extensive programming environment of interlisp is presented. Two aspects of the package are described: first, the functional view of display output and interactive input facilities as seen by the programmer, and second, the methods used to link the display terminal to the main computer via a packet-switched computer network. Recommendations are presented for designing operating systems and programming languages so as to simplify attaching display terminals.",
      "URL": "https://doi.org/10.1145/800249.807428",
      "DOI": "10.1145/800249.807428",
      "ISBN": "978-0-89791-004-4",
      "author": [
        {
          "family": "Sproull",
          "given": "Robert F."
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1979",
            8,
            1
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            15
          ]
        ]
      }
    },
    {
      "id": "9296070/H5Q65H3M",
      "type": "paper-conference",
      "title": "Extending Interlisp for modularization and efficiency",
      "container-title": "Proceedings of the International Symposiumon on Symbolic and Algebraic Computation",
      "collection-title": "EUROSAM '79",
      "publisher": "Springer-Verlag",
      "publisher-place": "Berlin, Heidelberg",
      "page": "481–489",
      "event-place": "Berlin, Heidelberg",
      "URL": "https://dl.acm.org/doi/10.5555/646670.699000",
      "ISBN": "978-3-540-09519-5",
      "author": [
        {
          "family": "Bobrow",
          "given": "Daniel G."
        },
        {
          "family": "Deutsch",
          "given": "L. Peter"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1979",
            6,
            1
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            6,
            3
          ]
        ]
      }
    },
    {
      "id": "9296070/IZ6P44N3",
      "type": "article-journal",
      "title": "A display oriented programmer's assistant",
      "container-title": "International Journal of Man-Machine Studies",
      "page": "157-187",
      "volume": "11",
      "issue": "2",
      "abstract": "This paper continues and extends previous work by the author in developing systems which provide the user with various forms of explicit and implicit assistance, and in general co-operate with the user in the development of his programs. The system described in this paper makes extensive use of a bit map display and pointing device (a mouse) to significantly enrich the user's interactions with the system, and to provide capabilities not possible with terminals that essentially emulate hard copy devices. For example, any text that is displayed on the screen can be pointed at and treated as input, exactly as though it were typed, i.e. the user can say use this expression or that value, and then simply point. The user views his programming environment through a collection of display windows, each of which corresponds to a different task or context. The user can manipulate the windows, or the contents of a particular window, by a combination of keyboard inputs or pointing operations. The technique of using different windows for different tasks makes it easy for the user to manage several simultaneous tasks and contexts, e.g. defining programs, testing programs, editing, asking the system for assistance, sending and receiving messages, etc. and to switch back and forth between these tasks at his convenience.",
      "URL": "https://www.sciencedirect.com/science/article/pii/S0020737379800152",
      "DOI": "10.1016/S0020-7373(79)80015-2",
      "journalAbbreviation": "International Journal of Man-Machine Studies",
      "language": "en",
      "author": [
        {
          "family": "Teitelman",
          "given": "Warren"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1979",
            3,
            1
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            5,
            31
          ]
        ]
      }
    },
    {
      "id": "9296070/59BVIIF8",
      "type": "report",
      "title": "The INTERLISP Virtual Machine Specification: Revised",
      "page": "126",
      "abstract": "The INTERLISP Virtual Machine is the environment in which the INTERLISP System is implemented. It includes such abstract objects as ~Literal Atom s~. List CelIs~, ‘Integers. etc.. the basic LISP functions for manipulating them, the underlying program control, and variable binding mechanisms. the input/output facilities, and interrupt processing facilities. In order to implement the INTERLISP System (as described in The INTERLISP Reference Manual by W. Teitelman. et. al.) on some physical machine, it is only necessary to implement the INTERLISP Virtual Machine. since Virtual Machine compatible source code for the rest of the INTERLISP System can be obtained from publicly available files. This document specifies the behavior of the INTERLISP Virtual Machine from the implementor s point of view. That is. it is an attempt to make explicit those things that must be implemented to allow the INTERLISP System to run on some machine.",
      "URL": "http://www.cs.utexas.edu/~moore/publications/interlisp-vm.pdf",
      "author": [
        {
          "family": "Moore",
          "given": "J. Strother"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1979",
            3
          ]
        ]
      }
    },
    {
      "id": "9296070/BSE5UV9A",
      "type": "article-journal",
      "title": "Compact Encodings of List Structure",
      "container-title": "ACM Transactions on Programming Languages and Systems",
      "page": "266-286",
      "volume": "1",
      "issue": "2",
      "abstract": "List structures provide a general mechanism for representing easily changed structured data, but can introduce inefficiencies in the use of space when fields of uniform size are used to contain pointers to data and to link the structure. Empirically determined regularity can be exploited to provide more space-efficient encodings without losing the flexibility inherent in list structures. The basic scheme is to provide compact pointer fields big enough to accommodate most values that occur in them and to provide “escape” mechanisms for exceptional cases. Several examples of encoding designs are presented and evaluated, including two designs currently used in Lisp machines. Alternative escape mechanisms are described, and various questions of cost and implementation are discussed. In order to extrapolate our results to larger systems than those measured, we propose a model for the generation of list pointers and we test the model against data from two programs. We show that according to our model, list structures with compact cdr fields will, as address space grows, continue to be compacted well with a fixed-width small field. Our conclusion is that with a microcodable processor, about a factor of two gain in space efficiency for list structure can be had for little or no cost in processing time.",
      "URL": "https://dl.acm.org/doi/10.1145/357073.357081",
      "DOI": "10.1145/357073.357081",
      "journalAbbreviation": "ACM Trans. Program. Lang. Syst.",
      "language": "en",
      "author": [
        {
          "family": "Bobrow",
          "given": "Daniel G."
        },
        {
          "family": "Clark",
          "given": "Douglas W."
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1979",
            10
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            21
          ]
        ]
      }
    }
  ],
  "1980": [
    {
      "id": "9296070/4EDHAKDB",
      "type": "paper-conference",
      "title": "Local optimization in a compiler for stack-based Lisp machines",
      "container-title": "Proceedings of the 1980 ACM conference on LISP and functional programming",
      "collection-title": "LFP '80",
      "publisher": "Association for Computing Machinery",
      "publisher-place": "New York, NY, USA",
      "page": "223–230",
      "event-place": "New York, NY, USA",
      "abstract": "We describe the local optimization phase of a compiler for translating the INTERLISP dialect of LISP into stack-architecture (0-address) instruction sets. We discuss the general organization of the compiler, and then describe the set of optimization techniques found most useful, based on empirical results gathered by compiling a large set of programs. The compiler and optimization phase are machine independent, in that they generate a stream of instructions for an abstract stack machine, which an assembler subsequently turns into the actual machine instructions. The compiler has been in successful use for several years, producing code for two different instruction sets.",
      "URL": "https://doi.org/10.1145/800087.802810",
      "DOI": "10.1145/800087.802810",
      "ISBN": "978-1-4503-7396-8",
      "author": [
        {
          "family": "Masinter",
          "given": "Larry M."
        },
        {
          "family": "Deutsch",
          "given": "L. Peter"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1980",
            8,
            25
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            26
          ]
        ]
      }
    },
    {
      "id": "9296070/8SMP58AA",
      "type": "paper-conference",
      "title": "ByteLisp and its Alto implementation",
      "container-title": "Proceedings of the 1980 ACM conference on LISP and functional programming",
      "collection-title": "LFP '80",
      "publisher": "Association for Computing Machinery",
      "publisher-place": "New York, NY, USA",
      "page": "231–242",
      "event-place": "New York, NY, USA",
      "abstract": "This paper describes in detail the most interesting aspects of ByteLisp, a transportable Lisp system architecture which implements the Interlisp dialect of Lisp, and its first implementation, on a microprogrammed minicomputer called the Alto. Two forthcoming related papers will deal with general questions of Lisp machine and system architecture, and detailed measurements of the Alto ByteLisp system described here. A highly condensed summary of the series was published at MICRO-11 in November 197815.",
      "URL": "https://doi.org/10.1145/800087.802811",
      "DOI": "10.1145/800087.802811",
      "ISBN": "978-1-4503-7396-8",
      "author": [
        {
          "family": "Deutsch",
          "given": "L. Peter"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1980",
            8,
            25
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            5,
            31
          ]
        ]
      }
    },
    {
      "id": "9296070/WPDGQV37",
      "type": "paper-conference",
      "title": "Overview and status of DoradoLisp",
      "container-title": "Proceedings of the 1980 ACM conference on LISP and functional programming",
      "collection-title": "LFP '80",
      "publisher": "Association for Computing Machinery",
      "publisher-place": "New York, NY, USA",
      "page": "243-247",
      "event-place": "New York, NY, USA",
      "abstract": "DoradoLisp is an implementation of the Interlisp programming system on a large personal computer. It has evolved from AltoLisp, an implementation on a less powerful machine. The major goal of the Dorado implementation was to eliminate the performance deficiencies of the previous system. This paper describes the current status of the system and discusses some of the issues that arose during its implementation. Among the techniques that helped us meet our performance goal were transferring much of the kernel software into Lisp, intensive use of performance measurement tools to determine the areas of worst performance, and use of the Interlisp programming environment to allow rapid and widespread improvements to the system code. The paper lists some areas in which performance was critical and offers some observations on how our experience might be useful to other implementations of Interlisp.",
      "URL": "https://doi.org/10.1145/800087.802812",
      "DOI": "10.1145/800087.802812",
      "ISBN": "978-1-4503-7396-8",
      "author": [
        {
          "family": "Burton",
          "given": "Richard R."
        },
        {
          "family": "Masinter",
          "given": "L. M."
        },
        {
          "family": "Bobrow",
          "given": "Daniel G."
        },
        {
          "family": "Haugeland",
          "given": "Willie Sue"
        },
        {
          "family": "Kaplan",
          "given": "Ronald M."
        },
        {
          "family": "Sheil",
          "given": "B. A."
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1980",
            8,
            25
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            25
          ]
        ]
      }
    },
    {
      "id": "9296070/L6DXES8K",
      "type": "article-journal",
      "title": "Special issue on knowledge representation",
      "container-title": "ACM SIGART Bulletin",
      "page": "1-138",
      "issue": "70",
      "abstract": "In the fall of 1978 we decided to produce a special issue of the SIGART Newsletter devoted to a survey of current knowledge representation research. We felt that there were twe useful functions such an issue could serve. First, we hoped to elicit a clear picture of how people working in this subdiscipline understand knowledge representation research, to illuminate the issues on which current research is focused, and to catalogue what approaches and techniques are currently being developed. Second -- and this is why we envisaged the issue as a survey of many different groups and projects -- we wanted to provide a document that would enable the reader to acquire at least an approximate sense of how each of the many different research endesvours around the world fit into the field as a whole.It would of course be impossible to produce a final or definitive document accomplishing these goals: rather, we hoped that this survey could initiate a continuing dialogue on issues in representation, a project for which this newsletter seems the ideal forum. It has been many months since our original decision was made, but we are finally able to present the results of that survey. Perhaps more than anything else, it has emerged as a testament to an astounding range and variety of opinions held by many different people in many different places.The following few pages are intended as an introduction to the survey as a whole, and to this issue of the newsletter. We will briefly summarize the form that the survey took, discuss the strategies we followed in analyzing and tabulating responses, briefly review the overall sense we received from the answers that were submitted, and discuss various criticisms which were submitted along with the responses. The remainder of the volume has been designed to be roughly self-explanatory at each point, so that one may dip into it at different places at will. Certain conventions, however, particularly regarding indexing and tabulating, will also be explained in the remainder of this introduction.As editors, we are enormously grateful to the many people who devoted substantial effort to responding to our survey. It is our hope that the material presented here will be interesting and helpful to our readers, and that fruitful discussion of these and other issues will continue energetically and enthusiastically into the future.",
      "URL": "https://doi.org/10.1145/1056751.1056752",
      "DOI": "10.1145/1056751.1056752",
      "journalAbbreviation": "SIGART Bull.",
      "author": [
        {
          "family": "Brachman",
          "given": "Ronald J."
        },
        {
          "family": "Smith",
          "given": "Brian C."
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1980",
            2,
            1
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            25
          ]
        ]
      }
    },
    {
      "id": "9296070/9B3ESHMP",
      "type": "report",
      "title": "Papers on interlisp-D",
      "collection-title": "COGNITIVE AND INSTRUCTIONAL SCIENCES SERIES CIS.5 (SSL-80-4",
      "page": "52",
      "abstract": "This report consists of five papers on Interlisp-0, a refinement and implementation of the\nI[ tnterlisp virtual machine [Moore, 761 which supports the interlisp programming system\n[Teitelman et at., 781 on the Dolphin and Dorado personal computers",
      "URL": "http://www.softwarepreservation.net/projects/LISP/interlisp-d/Papers_On_Interlisp-D.pdf",
      "author": [
        {
          "family": "Burton",
          "given": "Richard R."
        },
        {
          "family": "Kaplan",
          "given": "Ronald M."
        },
        {
          "family": "Masinter",
          "given": "B."
        },
        {
          "family": "Sheil",
          "given": "B. A."
        },
        {
          "family": "Bell",
          "given": "A."
        },
        {
          "family": "Bobrow",
          "given": "D. G."
        },
        {
          "family": "Deutsch",
          "given": "L. P."
        },
        {
          "family": "Haugeland",
          "given": "W. S."
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1980",
            9
          ]
        ]
      }
    }
  ],
  "1981": [
    {
      "id": "9296070/6BCFJ639",
      "type": "report",
      "title": "Interlisp-VAX: A Report",
      "publisher": "Department of Computer Science, Stanford University",
      "publisher-place": "Stailford University Stanford, CA 94305",
      "page": "13",
      "event-place": "Stailford University Stanford, CA 94305",
      "URL": "http://www.softwarepreservation.org/projects/LISP/interlisp/Interlisp-VAX_A_Report.pdf/view",
      "number": "SUN-CS-81-879",
      "author": [
        {
          "family": "Masintcr",
          "given": "Larry M."
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1981",
            8,
            1
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            23
          ]
        ]
      }
    },
    {
      "id": "9296070/W96JCCYH",
      "type": "paper-conference",
      "title": "Overview of a display-oriented editor for INTERLISP",
      "container-title": "Proceedings of the 7th international joint conference on Artificial intelligence - Volume 2",
      "collection-title": "IJCAI'81",
      "publisher": "Morgan Kaufmann Publishers Inc.",
      "publisher-place": "San Francisco, CA, USA",
      "page": "927–929",
      "event-place": "San Francisco, CA, USA",
      "abstract": "DED is a display-oriented editor that was designed to add the power and convenience of display terminals to INTERLISPs teletype-oriented structure editor. DED divides the display screen into a Prettypnnt Region and an Interaction Region. The Prettypnnt Region gives a prettyprinted view of the structure being edited; the Interaction Region contains the interaction between the user and INTERLISPs standard editor. DEDs prettyprinter allows ellision, and the user may zoom in or out to see the expression being edited with more or less detail. There are several arrow keys which allow the user to change quite easily the locus of attention in certain structural ways, as well as a menu-like facility for common command sequences. Together, these features provide a display-facility that considerably augments INTERLISPs otherwise quite sophisticated user interface.",
      "URL": "https://dl.acm.org/doi/abs/10.5555/1623264.1623329",
      "author": [
        {
          "family": "Barstow",
          "given": "David R."
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1981",
            8,
            24
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            5,
            4
          ]
        ]
      }
    },
    {
      "id": "9296070/C6TTQVYB",
      "type": "article-journal",
      "title": "Interlisp-D: further steps in the flight from time-sharing",
      "container-title": "ACM SIGART Bulletin",
      "page": "31–32",
      "issue": "77",
      "abstract": "The Interslip-D project was formed to develop a personal machine inplementation of Interlisp for use as an environment for research in artificial intelligence and cognitive science [Burton et al., 80b]. This note describes the principal developments since our last report almost a year ago [Burton et al., 80a].",
      "URL": "https://doi.org/10.1145/1056743.1056745",
      "DOI": "10.1145/1056743.1056745",
      "shortTitle": "Interlisp-D",
      "journalAbbreviation": "SIGART Bull.",
      "author": [
        {
          "family": "Sheil",
          "given": "Beau"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1981",
            7,
            1
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            15
          ]
        ]
      }
    }
  ],
  "1982": [
    {
      "id": "9296070/G4F5FZND",
      "type": "paper-conference",
      "title": "Implementation of Interlisp on the VAX",
      "container-title": "Proceedings of the 1982 ACM symposium on LISP and functional programming  - LFP '82",
      "publisher": "ACM Press",
      "publisher-place": "Pittsburgh, Pennsylvania, United States",
      "page": "81-87",
      "event": "the 1982 ACM symposium",
      "event-place": "Pittsburgh, Pennsylvania, United States",
      "abstract": "This paper presents some of the issues involved in implementing Interlisp [19] on a VAX computer [24] with the goal of producing a version that runs under UNIX[17], specifically Berkeley VM/UNIX. This implementation has the following goals:\n• To be compatible with and functionally equivalent to Interlisp-10.\n\n• To serve as a basis for future Interlisp implementations on other mainframe computers. This goal requires that the implementation to be portable.\n\n• To support a large virtual address space.\n\n• To achieve a reasonable speed.\n\nThe implemention draws directly from three sources, Interlisp-10 [19], Interlisp-D [5], and Multilisp [12]. Interlisp-10, the progenitor of all Interlisps, runs on the PDP-10 under the TENEX [2] and TOPS-20 operating systems. Interlisp-D, developed at Xerox Palo Alto Research Center, runs on personal computers also developed at PARC. Multilisp, developed at the University of British Columbia, is a portable interpreter containing a kernel of Interlisp, written in Pascal [9] and running on the IBM Series/370 and the VAX. The Interlisp-VAX implementation relies heavily on these implementations. In turn, Interlisp-D and Multilisp were developed from The Interlisp Virtual Machine Specification [15] by J Moore (subsequently referred to as the VM specification), which discusses what is needed to implement an Interlisp by describing an Interlisp Virtual Machine from the implementors' point of view. Approximately six man-years of effort have been spent exclusively in developing Interlisp-VAX, plus the benefit of many years of development for the previous Interlisp implementations.",
      "URL": "http://portal.acm.org/citation.cfm?doid=800068.802138",
      "DOI": "10.1145/800068.802138",
      "ISBN": "978-0-89791-082-6",
      "language": "en",
      "author": [
        {
          "family": "Bates",
          "given": "Raymond L."
        },
        {
          "family": "Dyer",
          "given": "David"
        },
        {
          "family": "Koomen",
          "given": "Johannes A. G. M."
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1982",
            8
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            16
          ]
        ]
      }
    },
    {
      "id": "9296070/8AB9NPK7",
      "type": "book",
      "title": "Interlisp-VAX Users Manual",
      "publisher": "Xerox Corporation",
      "publisher-place": "300 N. Halstead St. Pasadena CA 91107 USA",
      "number-of-pages": "57",
      "edition": "First",
      "event-place": "300 N. Halstead St. Pasadena CA 91107 USA",
      "URL": "http://www.softwarepreservation.org/projects/LISP/interlisp/Interlisp-VAX-Users_Manual.pdf/view",
      "language": "English",
      "author": [
        {
          "family": "Bates",
          "given": "Raymond"
        },
        {
          "family": "David",
          "given": "Dayer"
        },
        {
          "family": "Koomen",
          "given": "Johannes"
        },
        {
          "family": "Saunders",
          "given": "Steven"
        },
        {
          "family": "Voreck",
          "given": "Donald"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1982",
            12,
            5
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            23
          ]
        ]
      }
    }
  ],
  "1983": [
    {
      "id": "9296070/XR77BB2T",
      "type": "paper-conference",
      "title": "Large-scale system development in several lisp environments",
      "container-title": "Proceedings of the Eighth international joint conference on Artificial intelligence - Volume 2",
      "collection-title": "IJCAI'83",
      "publisher": "Morgan Kaufmann Publishers Inc.",
      "publisher-place": "San Francisco",
      "page": "859–861",
      "event-place": "San Francisco",
      "abstract": "ROSS [7] is an object-oriented language developed for building knowledge-based simulations [4]. SWIRL [5, 6] is a program written in ROSS that embeds knowledge about defensive and offensive air battle strategies. Given an initial configuration of military forces, SWIRL simulates the resulting air battle. We have implemented ROSS and SWIRL in several different Lisp environments. We report upon this experience by comparing the various environments in terms of cpu usage, real-time usage, and various user aids.",
      "URL": "https://dl.acm.org/doi/10.5555/1623516.1623579",
      "author": [
        {
          "family": "Naraln",
          "given": "Sanjai"
        },
        {
          "family": "McArthur",
          "given": "David"
        },
        {
          "family": "Klahr",
          "given": "Philip"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1983",
            8,
            8
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            6,
            3
          ]
        ]
      }
    },
    {
      "id": "9296070/MSBZ5IMI",
      "type": "article",
      "title": "Interlisp reference manual",
      "publisher": "Xerox Corporation",
      "abstract": "Interlisp began with an implementation of the Lisp programming language for the PDP-1 at Bolt. Beranek and Newman in 1966. It was followed in 1967 by 940 Lisp, an upward compatible implementation for\nthe SDS-940 computer. 940 Lisp was the first Lisp system to demonstrate the feasibility of using software paging techniques and a large vinual memory in conjunction with a list-processing system [Bobrow & ( -----\\\n) Murphy, 1967]. 940 Lisp was patterned after the Lisp 1.5 ~plementation for CTSS at MIT, with several' ) 1ew facilities added to take advantage of its timeshared. on-line environment. DWIM, the Do-What+\nMean error correction facility, was introduced into this system in 1968 by Warren Teitelman [Teitelman. 1969].",
      "URL": "https://larrymasinter.net/86-interlisp-manual-opt.pdf",
      "note": "OCLC: 802551877",
      "shortTitle": "Interlisp reference manual",
      "language": "English",
      "author": [
        {
          "family": "Xerox",
          "given": ""
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1983",
            10
          ]
        ]
      }
    },
    {
      "id": "9296070/E5NDSA26",
      "type": "report",
      "title": "AQINTERLISP: An INTERLISP Program for Inductive Generalization of VL1 Event Sets",
      "publisher": "University of Illinois Urbana-Champaign",
      "URL": "https://www.mli.gmu.edu/papers/81-85/83-28.pdf",
      "number": "ISG 83-28",
      "shortTitle": "AQINTERLISP",
      "author": [
        {
          "family": "Becker",
          "given": "Jeffrey M."
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1983",
            9
          ]
        ]
      }
    }
  ],
  "1984": [
    {
      "id": "9296070/BNAYT94G",
      "type": "paper-conference",
      "title": "Recent developments in ISI-interlisp",
      "container-title": "Proceedings of the 1984 ACM Symposium on LISP and functional programming",
      "collection-title": "LFP '84",
      "publisher": "Association for Computing Machinery",
      "publisher-place": "New York, NY, USA",
      "page": "129–139",
      "event-place": "New York, NY, USA",
      "abstract": "This paper reports on recent developments of the ISI- Interlisp implementation of Interlisp on a VAX computer. ISI-Interlisp currently runs under UNIX, specifically the Berkeley VM/UNIX and VMS operating systems. Particular attention is paid to the current status of the implementation and the growing pains experienced in the last few years. Included is a discussion of the conversion from UNIX to VAX/VMS, recent modifications and improvements, current limitations, and projected goals. Since much of the recent effort has concerned performance tuning, our observations on this activity are included. ISI-Interlisp, formerly known as Interlisp-VAX, was reported in 1982 ACM Symposium on LISP and Functional Programming, August 1982 [1]. Experiences and recommendations since the 1982 LISP conference are presented.",
      "URL": "https://doi.org/10.1145/800055.802029",
      "DOI": "10.1145/800055.802029",
      "ISBN": "978-0-89791-142-3",
      "author": [
        {
          "family": "Bates",
          "given": "Raymond L."
        },
        {
          "family": "Dyer",
          "given": "David"
        },
        {
          "family": "Feber",
          "given": "Mark"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1984",
            8,
            6
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            6,
            2
          ]
        ]
      }
    }
  ],
  "1985": [
    {
      "id": "9296070/MVHYRDBF",
      "type": "article-journal",
      "title": "Understanding and solving arithmetic word problems: A computer simulation",
      "container-title": "Behavior Research Methods, Instruments, & Computers",
      "page": "565-571",
      "volume": "17",
      "issue": "5",
      "URL": "http://link.springer.com/10.3758/BF03207654",
      "DOI": "10.3758/BF03207654",
      "shortTitle": "Understanding and solving arithmetic word problems",
      "journalAbbreviation": "Behavior Research Methods, Instruments, & Computers",
      "language": "en",
      "author": [
        {
          "family": "Fletcher",
          "given": "Charles R."
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1985"
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2022,
            8,
            4
          ]
        ]
      }
    },
    {
      "id": "9296070/PMXCAM4Y",
      "type": "article",
      "title": "1985 Harmony and Intermezzo releases Koto release (for Xerox 1186), some bits of Common Lisp",
      "URL": "https://www.google.com/search?client=firefox-b-d&q=1985+Harmony+and+Intermezzo+releases+Koto+release+%28for+Xerox+1186%29%2C+some+bits+of+Common+Lisp",
      "language": "English",
      "author": [
        {
          "family": "XEROX",
          "given": ""
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1985",
            12
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            21
          ]
        ]
      }
    },
    {
      "id": "9296070/YC65PT77",
      "type": "article",
      "title": "Koro INTERLISP-D RELEASE NOTES",
      "publisher": "Xerox Corporation",
      "abstract": "The Koto release of Interlisp-D provides a wide range of added functionality, increased performance and improved reliability Central among these is that Koto is the first release of Interlisp that supports the new Xerox 1185i1186 artificial intelligence work stations, including the new features of these work stations such as the expanded 19\" display and the PC emulation option. Of course, like previous releases of Interlisp, Koto also supports the other current members of the 1100 series of machines, specifically the 1132 and various models of the 1108.",
      "URL": "http://www.bitsavers.org/pdf/xerox/interlisp-d/198706_Lyric/3102464_Lyric_Common_Lisp_Implementation_Notes_Jun87.pdf",
      "language": "English",
      "author": [
        {
          "family": "Anonymous",
          "given": ""
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1985",
            12
          ]
        ]
      }
    },
    {
      "id": "9296070/FKDCVZJ5",
      "type": "paper-conference",
      "title": "Language-based environment for natural language parsing",
      "container-title": "Proceedings of the second conference on European chapter of the Association for Computational Linguistics",
      "collection-title": "EACL '85",
      "publisher": "Association for Computational Linguistics",
      "publisher-place": "USA",
      "page": "98–106",
      "event-place": "USA",
      "abstract": "This paper introduces a special programming environment for the definition of grammars and for the implementation of corresponding parsers. In natural language processing systems it is advantageous to have linguistic knowledge and processing mechanisms separated. Our environment accepts grammars consisting of binary dependency relations and grammatical functions. Well-formed expressions of functions and relations provide constituent surroundings for syntactic categories in the form of two-way automata. These relations, functions, and automata are described in a special definition language.In focusing on high level descriptions a linguist may ignore computational details of the parsing process. He writes the grammar into a DPL-description and a compiler translates it into efficient LISP-code. The environment has also a tracing facility for the parsing process, grammar-sensitive lexical maintenance programs, and routines for the interactive graphic display of parse trees and grammar definitions. Translator routines are also available for the transport of compiled code between various LISP-dialects. The environment itself exists currently in INTERLISP and FRANZLISP. This paper focuses on knowledge engineering issues and does not enter linguistic argumentation.",
      "URL": "https://doi.org/10.3115/976931.976946",
      "DOI": "10.3115/976931.976946",
      "author": [
        {
          "family": "Lehtola",
          "given": "A."
        },
        {
          "family": "Jäppinen",
          "given": "H."
        },
        {
          "family": "Nelimarkka",
          "given": "E."
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1985",
            3,
            27
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            15
          ]
        ]
      }
    },
    {
      "id": "9296070/6D2EJDZD",
      "type": "book",
      "title": "Interlisp-D Reference Manual, Volume III: Input/Output",
      "publisher": "Xerox Corporation",
      "publisher-place": "S.l.",
      "volume": "3",
      "number-of-pages": "388",
      "event-place": "S.l.",
      "URL": "http://www.bitsavers.org/pdf/xerox/interlisp-d/198510_Koto/3101274_Interlisp-D_Vol_3_Input_Output_Oct85.pdf",
      "note": "OCLC: 802551877",
      "shortTitle": "Volume III: Input/Output",
      "language": "English",
      "editor": [
        {
          "family": "Sannella",
          "given": "Michael"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1985",
            10
          ]
        ]
      }
    },
    {
      "id": "9296070/PUQ8EKTK",
      "type": "book",
      "title": "Interlisp-D Reference Manual, Volume II: Environment",
      "publisher": "Xerox Corporation",
      "publisher-place": "S.l.",
      "volume": "2",
      "number-of-pages": "436",
      "event-place": "S.l.",
      "URL": "http://www.bitsavers.org/pdf/xerox/interlisp-d/198510_Koto/3101273_Interlisp-D_Vol_2_Environment_Oct85.pdf",
      "note": "OCLC: 802551877",
      "shortTitle": "Volume II: Environment",
      "language": "English",
      "editor": [
        {
          "family": "Sannella",
          "given": "Michael"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1985",
            10
          ]
        ]
      }
    },
    {
      "id": "9296070/DXD65IKD",
      "type": "book",
      "title": "Interlisp-D Reference Manual, Volume I: Language",
      "publisher": "Xerox Corporation",
      "publisher-place": "S.l.",
      "volume": "1",
      "number-of-pages": "296",
      "event-place": "S.l.",
      "URL": "http://www.bitsavers.org/pdf/xerox/interlisp-d/198510_Koto/3101272_Interlisp-D_Vol_1_Language_Oct85.pdf",
      "note": "OCLC: 802551877",
      "shortTitle": "Volume I: Language",
      "language": "English",
      "editor": [
        {
          "family": "Sannella",
          "given": "Michael"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1985",
            10
          ]
        ]
      }
    },
    {
      "id": "9296070/2B4J79N6",
      "type": "article-journal",
      "title": "Computer manipulation of geological exploration data",
      "container-title": "Journal of the Geological Society of London",
      "page": "925-926",
      "volume": "142",
      "issue": "5",
      "abstract": "Report of a meeting held by the Geological Information Group at the British Petroleum Research Centre, Sunbury, 24 January 1985\n\nThis meeting, concerned mainly with computer manipulation of petroleum exploration data, attracted c. 95 participants. In addition to eight papers presented, there were two computer demonstrations of log analysis systems and a number of poster displays.\n\nThe morning session, concerned with large-scale, integrated hardware and software systems, was chaired by R. Howarth. R. Till of British Petroleum gave the opening paper concerning BP Exploration’s integrated database system. BP Exploration databases fall into three main groups: those containing largely numerical data; databases specifically concerned with text handling; and well-based databases. The ‘numerical’ databases, implemented under the ULTRA database management system (dbms), include a seismic data system, a generalized cartographic database and an earth constants database. Textual databases include a library information system and a Petroconsultants scout data database, both implemented under the BASIS dbms. The well-based systems include a generalized well-data database, a wireline log archive, storage and retrieval system, and a master well index; all three are implemented under the INGRES dbms. Two related BASIS databases contain geochemical and biostratigraphical data.\n\nG. Baxter (co-author M. Hemingway) described the development of Britoil’s well log database which was prompted by the need to have rapid access to digitized wireline log data for c. 1500 wells on the UKCS. Early work involved both locating log information and digitizing those logs held in sepia form only. Each digitized log occupies approximately 1 Mbyte.",
      "URL": "http://jgs.lyellcollection.org/lookup/doi/10.1144/gsjgs.142.5.0925",
      "DOI": "10.1144/gsjgs.142.5.0925",
      "journalAbbreviation": "Journal of the Geological Society",
      "language": "en",
      "author": [
        {
          "family": "Burwell",
          "given": "A. D. M."
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1985",
            9,
            1
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            15
          ]
        ]
      }
    }
  ],
  "1986": [
    {
      "id": "9296070/3QK929A2",
      "type": "chapter",
      "title": "POWER TOOLS FOR PROGRAMMERS",
      "container-title": "Readings in Artificial Intelligence and Software Engineering",
      "publisher": "Morgan Kaufmann",
      "page": "573-580",
      "abstract": "This chapter discusses the power tools for programmers. Essentially, all of the intelligent programming tools described in this volume are at most experimental prototypes. Given that these tools are still quite far from being commercial realities, it is worthwhile to note that there is a completely different way in which artificial intelligence research has to help programmers. Artificial intelligence researchers are themselves programmers. Creating such programs is more a problem of exploration than implementation and does not conform to conventional software lifecycle models. The artificial intelligence programming community has always been faced with this kind of exploratory programming and has, therefore, had a head start on developing appropriate language, environment, and hardware features. Redundancy protects the design from unintentional change, the conventional programming technology restrains the programmer, and the programming languages used in exploratory systems minimize and defer constraints on the programmer.",
      "URL": "https://www.sciencedirect.com/science/article/pii/B9780934613125500483",
      "ISBN": "978-0-934613-12-5",
      "note": "DOI: 10.1016/B978-0-934613-12-5.50048-3",
      "shortTitle": "DATAMATION®",
      "language": "en",
      "author": [
        {
          "family": "Sheil",
          "given": "Beau"
        }
      ],
      "editor": [
        {
          "family": "Rich",
          "given": "Charles"
        },
        {
          "family": "Waters",
          "given": "Richard C."
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1986",
            1,
            1
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            6,
            2
          ]
        ]
      }
    },
    {
      "id": "9296070/YR58NY6F",
      "type": "paper-conference",
      "title": "CommonLoops: merging Lisp and object-oriented programming",
      "container-title": "Conference proceedings on Object-oriented programming systems, languages and applications",
      "collection-title": "OOPSLA '86",
      "publisher": "Association for Computing Machinery",
      "publisher-place": "New York, NY, USA",
      "page": "17-29",
      "event-place": "New York, NY, USA",
      "abstract": "CommonLoops blends object-oriented programming smoothly and tightly with the procedure-oriented design of Lisp. Functions and methods are combined in a more general abstraction. Message passing is invoked via normal Lisp function call. Methods are viewed as partial descriptions of procedures. Lisp data types are integrated with object classes. With these integrations, it is easy to incrementally move a program between the procedure and object-oriented styles. One of the most important properties of CommonLoops is its extensive use of meta-objects. We discuss three kinds of meta-objects: objects for classes, objects for methods, and objects for discriminators. We argue that these meta-objects make practical both efficient implementation and experimentation with new ideas for object-oriented programming. CommonLoops' small kernel is powerful enough to implement the major object-oriented systems in use today.",
      "URL": "https://doi.org/10.1145/28697.28700",
      "DOI": "10.1145/28697.28700",
      "ISBN": "978-0-89791-204-7",
      "shortTitle": "CommonLoops",
      "author": [
        {
          "family": "Bobrow",
          "given": "Daniel G."
        },
        {
          "family": "Kahn",
          "given": "Kenneth"
        },
        {
          "family": "Kiczales",
          "given": "Gregor"
        },
        {
          "family": "Masinter",
          "given": "Larry"
        },
        {
          "family": "Stefik",
          "given": "Mark"
        },
        {
          "family": "Zdybel",
          "given": "Frank"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1986",
            6,
            1
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            25
          ]
        ]
      }
    },
    {
      "id": "9296070/HLN62MVN",
      "type": "article-journal",
      "title": "CommonLoops: merging Lisp and object-oriented programming",
      "container-title": "ACM SIGPLAN Notices",
      "page": "17–29",
      "volume": "21",
      "issue": "11",
      "abstract": "CommonLoops blends object-oriented programming smoothly and tightly with the procedure-oriented design of Lisp. Functions and methods are combined in a more general abstraction. Message passing is invoked via normal Lisp function call. Methods are viewed as partial descriptions of procedures. Lisp data types are integrated with object classes. With these integrations, it is easy to incrementally move a program between the procedure and object-oriented styles. One of the most important properties of CommonLoops is its extensive use of meta-objects. We discuss three kinds of meta-objects: objects for classes, objects for methods, and objects for discriminators. We argue that these meta-objects make practical both efficient implementation and experimentation with new ideas for object-oriented programming. CommonLoops' small kernel is powerful enough to implement the major object-oriented systems in use today.",
      "URL": "https://doi.org/10.1145/960112.28700",
      "DOI": "10.1145/960112.28700",
      "shortTitle": "CommonLoops",
      "journalAbbreviation": "SIGPLAN Not.",
      "author": [
        {
          "family": "Bobrow",
          "given": "Daniel G."
        },
        {
          "family": "Kahn",
          "given": "Kenneth"
        },
        {
          "family": "Kiczales",
          "given": "Gregor"
        },
        {
          "family": "Masinter",
          "given": "Larry"
        },
        {
          "family": "Stefik",
          "given": "Mark"
        },
        {
          "family": "Zdybel",
          "given": "Frank"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1986",
            6,
            1
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            6,
            3
          ]
        ]
      }
    },
    {
      "id": "9296070/YEUXRBGZ",
      "type": "article",
      "title": "Artificial Intelligence Systems, Interlisp-D: A Friendly Primer",
      "publisher": "Xerox Corporation",
      "URL": "http://www.bitsavers.org/pdf/xerox/interlisp-d/198510_Koto/3102300_Interlisp-D_A_Friendly_Primer_Nov86.pdf",
      "language": "en",
      "author": [
        {
          "family": "Xerox",
          "given": ""
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1986",
            11
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            23
          ]
        ]
      }
    }
  ],
  "1987": [
    {
      "id": "9296070/EFHC285D",
      "type": "paper-conference",
      "title": "The background of INTERNIST I and QMR",
      "container-title": "Proceedings of ACM conference on History of medical informatics",
      "collection-title": "HMI '87",
      "publisher": "Association for Computing Machinery",
      "publisher-place": "New York, NY, USA",
      "page": "195–197",
      "event-place": "New York, NY, USA",
      "abstract": "During my tenure as Chairman of the Department of Medicine at the University of Pittsburgh, 1955 to 1970, two points became clear in regard to diagnosis in internal medicine. The first was that the knowledge base in that field had become vastly too large for any single person to encompass it. The second point was that the busy practitioner, even though he knew the items of information pertinent to his patients correct diagnosis, often did not consider the right answer particularly if the diagnosis was an unusual disease. I resigned the position of Chairman in 1970 intending to resume my position as Professor of Medicine. However, the University saw fit to offer me the appointment as University Professor (Medicine). The University of Pittsburgh follows the practice of Harvard University, established by President James Bryant Conant in the late 1930s, in which a University Professor is a professor at large and reports only to the president of the university. He has no department, no school and is not under administrative supervision by a dean or vice-president. Thus the position allows maximal academic freedom. In this new position I felt strongly that I should conduct worthwhile research. It was almost fifteen years since I had worked in my chosen field of clinical investigation, namely splanchnic blood flow and metabolism, and I felt that research in that area had passed me by. Remembering the two points mentioned earlier — the excessive knowledge base of internal medicine and the problem of considering the correct diagnosis — I asked myself what could be done to correct these problems. It seemed that the computer with its huge memory could correct the first and I wondered if it could not help as well with the second. At that point I knew no more about computers than the average layman so I sought advice. Dr. Gerhard Werner, our Chairman of Pharmacology, was working with computers in an attempt to map all of the neurological centers of the human brain stem with particular reference to their interconnections and functions. He was particularly concerned about the actions of pharmacological agents on this complex system. Working with him on this problem was Dr. Harry Pople, a computer scientist with special interest in “artificial intelligence”. The problem chosen was so complex and difficult that Werner and Pople were making little progress. Gerhard listened patiently to my ideas and promptly stated that he thought the projects were feasible utilizing the computer. In regard to the diagnostic component of my ambition he strongly advised that “artificial intelligence” be used. Pople was brought into the discussion and was greatly interested, I believe because of the feasibility of the project and the recognition of its practical application to the practice of medicine. The upshot was that Pople joined me in my project and Werner and Pople abandoned the work on the brain stem. Pople knew nothing about medicine and I knew nothing about computer science. Thus the first step in our collaboration was my analysis for Pople of the diagnostic process. I chose a goodly number of actual cases from clinical pathological conferences (CPCs) because they contained ample clinical data and because the correct diagnoses were known. At each small step of the way through the diagnostic process I was required to explain what the clinical information meant in context and my reasons for considering certain diagnoses. This provided to Pople insight into the diagnostic process. After analyzing dozens of such cases I felt as though I had undergone a sort of “psychoanalysis”. From this experience Pople wrote the first computer diagnostic programs seeking to emulate my diagnostic process. This has led certain “wags” to nickname our project “Jack in the box”. For this initial attempt Pople used the LISP computer language. We were granted access to the PROPHET PDP-10, a time-sharing mainframe maintained in Boston by the National Institutes of Health (NIH) but devoted particularly to pharmacological research. Thus we were interlopers. The first name we applied to our project was DIALOG, for diagnostic logic, but this had to be dropped because the name was in conflict with a computer program already on the market and copyrighted. The next name chosen was INTERNIST for obvious reason. However, the American Society for Internal Medicine publishes a journal entitled “The Internist” and they objected to our use of INTERNIST although there seems to be little relationship or conflict between a printed journal and a computer software program. Rather than fight the issue we simply added the Roman numeral one to our title which then became INTERNIST-I, which continues to this day. Pople's initial effort was unsuccessful, however. He diligently had incorporated details regarding anatomy and much basic pathophysiology, I believe because in my initial CPC analyses I had brought into consideration such items of information so that Pople could understand how I got from A to B etc. The diagnostician in internal medicine knows, of course, much anatomy and patho-physiology but these are brought into consideration in only a minority of diagnostic problems. He knows, for example, that the liver is in the right upper quadrant and just beneath the right leaf of the diaphragm. In most diagnostic instances this information is “subconscious”. Our first computer diagnostic program included too many such details and as a result was very slow and frequently got into analytical “loops” from which it could not extricate itself. We decided that we had to simplify the program but by that juncture much of 1971 had passed on. The new program was INTERNIST-I and even today most of the basic structure devised in 1972 remains intact. INTERNIST-I is written in INTERLISP and has operated on the PDP-10 and the DEC 2060. It has also been adapted to the VAX 780. Certain younger people have contributed significantly to the program, particularly Dr. Zachary Moraitis and Dr. Randolph Miller. The latter interrupted his regular medical school education to spend the year 1974-75 as a fellow in our laboratory and since finishing his formal medical education in 1979 has been active as a full time faculty member of the team. Several Ph.D. candidates in computer science have also made significant contributions as have dozens of medical students during electives on the project. INTERNIST-I is really quite a simple system as far as its operating system or inference engine is concerned. Three basic numbers are concerned in and manipulated in the ranking of elicited disease hypotheses. The first of these is the importance (IMPORT) of each of the more than 4,100 manifestations of disease which are contained in the knowledge base. IMPORTS are a global representation of the clinical importance of a given finding graded from 1 to 5, the latter being maximal, focusing on how necessary it is to explain the manifestation regardless of the final diagnosis. Thus massive splenomegaly has an IMPORT of 5 whereas anorexia has an IMPORT of 1. Mathematical weights are assigned to IMPORT numbers on a non-linear scale. The second basic number is the evoking strength (EVOKS), the numbers ranging from 0 to 5. The number answers the question, that given a particular manifestation of disease, how strongly does one consider disease A versus all other diagnostic possibilities in a clinical situation. A zero indicates that a particular clinical manifestation is non-specific, i.e. so widely spread among diseases that the above question cannot be answered usefully. Again, anorexia is a good example of a non-specific manifestation. The EVOKS number 5, on the other hand, indicates that a manifestation is essentially pathognomonic for a particular disease. The third basic number is the frequency (FREQ) which answers the question that given a particular disease what is the frequency or incidence of occurrence of a particular clinical finding. FREQ numbers range from 1 to 5, one indicating that the finding is rare or unusual in the disease and 5 indicating that the finding is present in essentially all instances of the disease. Each diagnosis which is evoked is ranked mathematically on the basis of support for it, both positive and negative. Like the import number, the values for EVOKS and FREQ numbers increase in a non-linear fashion. The establishment or conclusion of a diagnosis is not based on any absolute score, as in Bayesian systems, but on how much better is the support of diagnosis A as compared to its nearest competitor. This difference is anchored to the value of an EVOKS of 5, a pathognomonic finding. When the list of evoked diagnoses is ranked mathematically on the basis of EVOKS, FREQ and IMPORT, the list is partitioned based upon the similarity of support for individual diagnoses. Thus a heart disease is compared with other heart diseases and not brain diseases since the patient may have a heart disorder and a brain disease concommitantly. Thus apples are compared with apples and not oranges. When a diagnosis is concluded, the computer consults a list of interrelationships among diseases (LINKS) and bonuses are awarded, again in a non-linear fashion for numbers ranging from 1 to 5 — 1 indicating a weak interrelationship and 5 a universal interrelationship. Thus multiple interrelated diagnoses are preferred over independent ones provided the support for the second and other diagnoses is adequate. Good clinicians use this same rule of thumb. LINKS are of various types: PCED is used when disease A precedes disease B, e.g. acute rheumatic fever precedes early rheumatic valvular disease; PDIS - disease A predisposes to disease B, e.g. AIDS predisposes to pneumocystis pneumonia; CAUS - disease A causes disease B, e.g. thrombophlebitis of the lower extremities may cause pulmonary embolism; and COIN - there is a statistical interrelationship between disease A and disease B but scientific medical information is not explicit on the relationship, e.g. Hashimoto's thyroiditis coincides with pernicious anemia, both so called autoimmune diseases. The maximal number of correct diagnoses made in a single case analysis is, to my recollection, eleven. In working with INTERNIST-I during the remainder of the 1970s several important points about the system were learned or appreciated. The first and foremost of these is the importance of a complete and accurate knowledge base. Omissions from a disease profile can be particularly troublesome. If a manifestation of disease is not listed on a disease profile the computer can only conclude that that manifestation does not occur in the disease, and if a patient demonstrates the particular manifestation it counts against the diagnosis. Fortunately, repeated exercise of the diagnostic system brings to attention many inadvertent omissions. It is important to establish the EVOKS and FREQ numbers as accurately as possible. Continual updating of the knowledge base, including newly described diseases and new information about diseases previously profiled, is critical. Dr. Edward Feigenbaum recognized the importance of the accuracy and completeness of knowledge bases as the prime requisite of expert systems of any sort. He emphasized this point in his keynote address to MEDINFO-86 (1). Standardized, clear and explicit nomenclature is required in expressing disease names and particularly in naming the thousands of individual manifestations of disease. Such rigidity can make the use of INTERNIST-I difficult for the uninitiated user. Therefore, in QMR more latitude and guidance is provided the user. For example, the user of INTERNIST-I must enter ABDOMEN PAIN RIGHT UPPER QUADRANT exactly whereas in QMR the user may enter PAI ABD RUQ and the system recognizes the term as above. The importance of “properties” attached to the great majority of clinical manifestations was solidly evident. Properties express such conditions that if A is true then B is automatically false (or true as the case may be). The properties also allow credit to be awarded for or against B as the case may be. Properties also provide order to the asking of questions in the interrogative mode. They also state prerequisites and unrequisites for various procedures. As examples, one generally does not perform a superficial lymph node biopsy unless lymph nodes are enlarged (prerequisite). Similarly, a percutaneous liver biopsy is inadvisable if the blood platelets are less than 50,000 (unrequisite). It became clear quite early in the utilization of INTERNIST-I that systemic or multisystem diseases had an advantage versus localized disorders in diagnosis. This is because systemic diseases have very long and more inclusive manifestation lists. It became necessary, therefore, to subdivide systemic diseases into various components when appropriate. Systemic lupus erythematosus provides a good example. Lupus nephritis must be compared in our system with other renal diseases and such comparison is allowed by our partitioning algorithm. Likewise, cerebral lupus must be differentiated from other central nervous system disorders. Furthermore, either renal lupus or cerebral lupus can occur at times without significant clinical evidence of other systemic involvement. In order to reassemble the components of a systemic disease we devised the systemic LINK (SYST) which expresses the interrelationship of each subcomponent to the parent systemic disease. It became apparent quite early that expert systems like INTERNIST do not deal with the time axis of a disease well at all, and this seems to be generally true of expert systems in “artificial intelligence”. Certain parameters dealing with time can be expressed by devising particular manifestations, e.g. a blood transfusion preceding the development of acute hepatitis B by 2 to 6 months. But time remains a problem which is yet to be solved satisfactorily including QMR. It has been clearly apparent over the years that both the knowledge base and the diagnostic consultant programs of both INTERNIST-I and QMR have considerable educational value. The disease profiles, the list of diseases in which a given clinical manifestation occurs (ordered by EVOKS and FREQ), and the interconnections among diseases (LINKS) provide a quick and ready means of acquiring at least orienting clinical information. Such has proved useful not only to medical students and residents but to clinical practitioners as well. In the interrogative mode of the diagnostic systems the student will frequently ask “Why was that question asked?” An instructor can either provide insight or ready consultation of the knowledge base by the student will provide a simple semi-quantitative reason for the question. Lastly, let the author state that working with INTERNIST-I and QMR over the years seems to have had real influence on his own diagnostic approaches and habits. Thus my original psycho-analysis when working with Pople has been reinforced.",
      "URL": "https://doi.org/10.1145/41526.41543",
      "DOI": "10.1145/41526.41543",
      "ISBN": "978-0-89791-248-8",
      "author": [
        {
          "family": "Myers",
          "given": "J. D."
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1987",
            12,
            1
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            15
          ]
        ]
      }
    },
    {
      "id": "9296070/25TEJPHA",
      "type": "article",
      "title": "XEROX COMMON LISP IMPLEMENTATION NOTES",
      "publisher": "XEROX",
      "abstract": "The Xerox Common Lisp Implementation Notes cover several aspects of the Lyric release. In these notes you will find:\n• An explanation of how Xerox Common Lisp extends the Common Lisp standard. For example, in Xerox Common Lisp the Common Lisp array-constructing function make-array has additional keyword\narguments that enhance its functionality.\n• An explanation of how several ambiguities in Steele's Common Lisp: the Language were\nresolved.\n• A description of additional features that provide far more than extensions to Common Lisp.",
      "URL": "http://www.bitsavers.org/pdf/xerox/interlisp-d/198706_Lyric/3102464_Lyric_Common_Lisp_Implementation_Notes_Jun87.pdf",
      "shortTitle": "IMPLEMENTATION NOTES",
      "language": "English",
      "author": [
        {
          "family": "Anonymous",
          "given": ""
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1987",
            6
          ]
        ]
      }
    },
    {
      "id": "9296070/F9XE85C9",
      "type": "article",
      "title": "Artificial intelligence Systems Xerox LOOPS, A Friendly Primer",
      "publisher": "Xerox Corporation",
      "URL": "http://www.bitsavers.org/pdf/xerox/interlisp-d/198510_Koto/3102242_Xerox_LOOPS_A_Friendly_Primer_Mar87.pdf",
      "shortTitle": "Interlisp-D_A-Friendly-Primer",
      "language": "en",
      "author": [
        {
          "family": "Mears",
          "given": "Lyn Ann"
        },
        {
          "family": "Rees",
          "given": "Ted"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1987",
            3
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            23
          ]
        ]
      }
    },
    {
      "id": "9296070/F9XE85C9",
      "type": "article",
      "title": "Artificial intelligence Systems Xerox LOOPS, A Friendly Primer",
      "publisher": "Xerox Corporation",
      "URL": "http://www.bitsavers.org/pdf/xerox/interlisp-d/198510_Koto/3102242_Xerox_LOOPS_A_Friendly_Primer_Mar87.pdf",
      "shortTitle": "Interlisp-D_A-Friendly-Primer",
      "language": "en",
      "author": [
        {
          "family": "Mears",
          "given": "Lyn Ann"
        },
        {
          "family": "Rees",
          "given": "Ted"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1987",
            3
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            23
          ]
        ]
      }
    }
  ],
  "1988": [
    {
      "id": "9296070/FDA3AUNV",
      "type": "article-journal",
      "title": "Bridging the gap between object-oriented and logic programming",
      "container-title": "IEEE Software",
      "page": "36-42",
      "volume": "5",
      "issue": "4",
      "URL": "http://ieeexplore.ieee.org/document/17800/",
      "DOI": "10.1109/52.17800",
      "journalAbbreviation": "IEEE Softw.",
      "language": "en",
      "author": [
        {
          "family": "Koschmann",
          "given": "T."
        },
        {
          "family": "Evens",
          "given": "M.W."
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1988"
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2022,
            8,
            4
          ]
        ]
      }
    }
  ],
  "1990": [
    {
      "id": "9296070/SYHYTLHH",
      "type": "patent",
      "title": "Design system using visual language",
      "abstract": "A computer-based tool, in the form of a computer system and method, for designing, constructing and interacting with any system containing or comprising concurrent asychronous processes, such as a factory operation. In the system according to the invention a variety of development and execution tools are supported. The invention features a highly visual user presentation of a control system, including structure, specification, and operation, offering a user an interactive capability for rapid design, modification, and exploration of the operating characteristics of a control system comprising asynchronous processes. The invention captures a representation of the system (RS) that is equivalent to the actual system (AS)--rather than a simulation of the actual system. This allows the invention to perform tests and modification on RS instead of AS, yet get accurate results. RS and AS are equivalent because AS is generated directly from RS by an automated process. Effectively, pressing a button in the RS environment can \"create\" the AS version or any selected portion of it, by \"downloading\" a translation of the RS version that can be executed by a programmable processor in the AS environment. Information can flow both ways between AS and RS. That AS and RS can interact is important. This allows RS to \"take on\" the \"state\" of AS whenever desired, through an \"uploading\" procedure, thereby reflecting accurately the condition of AS at a specific point in time.",
      "URL": "https://patents.google.com/patent/US4914567A/en",
      "number": "US4914567A",
      "author": [
        {
          "family": "Lipkis",
          "given": "Thomas A."
        },
        {
          "family": "Mark",
          "given": "William S."
        },
        {
          "family": "Pirtle",
          "given": "Melvin W."
        }
      ],
      "issued": {
        "date-parts": [
          [
            1990,
            4,
            3
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            6,
            1
          ]
        ]
      }
    }
  ],
  "1991": [
    {
      "id": "9296070/J62GHLSJ",
      "type": "patent",
      "title": "Method of and apparatus for composing a press imposition",
      "abstract": "An apparatus and a method are disclosed for composing an imposition in terms of an arrangement of printing plates on selected of the image positions on selected units of a printing press to print a given edition, by first assigning each section of this edition to one of the press areas. Thereafter, each printing unit is examined to determine an utilization value thereof in terms of the placement of the printing plates on the image positions and the relative number of image positions to which printing plates are assigned with respect to the total number of image positions. Thereafter, a list of the image positions for each of the sections and its area, is constructed by examining one printing unit at a time in an order according to the placement of that printing unit in the array and examining its utilization value to determine whether or not to include a particular image position of that printing unit in the list. As a result, a list of the image positions is constructed in a sequence corresponding to numerical order of the pages in the section under consideration. Finally, that list of the image positions and the corresponding section and page numbers is displayed in a suitable fashion to inform a user of how to place the printing plates in the desired arrangement onto the printing units of the press to print this given edition.",
      "URL": "https://patents.google.com/patent/US4984773A/en",
      "number": "US4984773A",
      "author": [
        {
          "family": "Balban",
          "given": "Morton S."
        },
        {
          "family": "Lan",
          "given": "Ming-Shong"
        },
        {
          "family": "Panos",
          "given": "Rodney M."
        }
      ],
      "issued": {
        "date-parts": [
          [
            1991,
            1,
            15
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            6,
            1
          ]
        ]
      }
    },
    {
      "id": "9296070/KXVS2RBT",
      "type": "patent",
      "title": "User interface with multiple workspaces for sharing display system objects",
      "abstract": "Workspaces provided by an object-based user interface appear to share windows and other display objects. Each workspace's data structure includes, for each window in that workspace, a linking data structure called a placement which links to the display system object which provides that window, which may be a display system object in a preexisting window system. The placement also contains display characteristics of the window when displayed in that workspace, such as position and size. Therefore, a display system object can be linked to several workspaces by a placement in each of the workspaces' data structures, and the window it provides to each of those workspaces can have unique display characteristics, yet appear to the user to be the same window or versions of the same window. As a result, the workspaces appear to be sharing a window. Workspaces can also appear to share a window if each workspace's data structure includes data linking to another workspace with a placement to the shared window. The user can invoke a switch between workspaces by selecting a display object called a door, and a back door to the previous workspace is created automatically so that the user is not trapped in a workspace. A display system object providing a window to a workspace being left remains active so that when that workspace is reentered, the window will have the same contents as when it disappeared. Also, the placements of a workspace are updated so that when the workspace is reentered its windows are organized the same as when the user left that workspace. The user can enter an overview display which shows a representation of each workspace and the windows it contains so that the user can navigate to any workspace from the overview.",
      "URL": "https://patents.google.com/patent/US5072412A/en",
      "number": "US5072412A",
      "author": [
        {
          "family": "Henderson",
          "given": "D. Austin"
        },
        {
          "family": "Card",
          "given": "Stuart K."
        },
        {
          "family": "Maxwell",
          "given": "John T."
        }
      ],
      "issued": {
        "date-parts": [
          [
            1991,
            12,
            10
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            6,
            1
          ]
        ]
      }
    },
    {
      "id": "9296070/5QACWN9U",
      "type": "patent",
      "title": "Interactive method of developing software interfaces",
      "abstract": "A system and method for interactive design of user manipulable graphic elements. A computer has display and stored tasks wherein the appearance of graphic elements and methods for their manipulation are defined. Each graphic element is defined by at least one figure specification, one mask specification and one map specification. An interactive display editor program defines specifications of said graphic elements. An interactive program editor program defines programming data and methods associated with said graphic elements. A display program uses the figure, map and mask specifications for assembling graphic elements upon the display and enabling user manipulation of said graphic elements.",
      "URL": "https://patents.google.com/patent/US5041992A/en",
      "number": "US5041992A",
      "author": [
        {
          "family": "Cunningham",
          "given": "Robert E."
        },
        {
          "family": "Bonar",
          "given": "Jeffery G."
        },
        {
          "family": "Corbett",
          "given": "John D."
        }
      ],
      "issued": {
        "date-parts": [
          [
            1991,
            8,
            20
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            6,
            1
          ]
        ]
      }
    },
    {
      "id": "9296070/TN3W6XLN",
      "type": "paper-conference",
      "title": "PEPYS: Generating Autobiographies by Automatic Tracking",
      "abstract": "This paper presents one part of a broad research project entitled 'Activity-Based Information Retrieval' (AIR) which is being carded out at EuroPARC. The basic hypothesis of this project is that if contextual data about human activities can be automatically captured and later presented as recognisable descriptions of past episodes, then human memory of those past episodes can be improved. This paper describes an application called Pepys, designed to yield descriptions of episodes based on automatically collected location data. The program pays particular attention to meetings and other episodes involving two or more people. The episodes are presented to the user as a diary generated at the end of each day and distributed by electronic mail. The paper also discusses the methods used to assess the accuracy of the descriptions generated by the recogniser.",
      "DOI": "10.1007/978-94-011-3506-1_13",
      "ISBN": "978-0-7923-1439-4",
      "shortTitle": "PEPYS",
      "author": [
        {
          "family": "Newman",
          "given": "William"
        },
        {
          "family": "Eldridge",
          "given": "Margery"
        },
        {
          "family": "Lamming",
          "given": "Michael"
        }
      ],
      "issued": {
        "date-parts": [
          [
            1991,
            1,
            1
          ]
        ]
      }
    }
  ],
  "1992": [
    {
      "id": "9296070/9SEIVVBA",
      "type": "paper-conference",
      "title": "Interactive constraint-based search and replace",
      "container-title": "Proceedings of the SIGCHI Conference on Human Factors in Computing Systems",
      "collection-title": "CHI '92",
      "publisher": "Association for Computing Machinery",
      "publisher-place": "New York, NY, USA",
      "page": "609–618",
      "event-place": "New York, NY, USA",
      "abstract": "We describe enhancements to graphical search and replace that allow users to extend the capabilities of a graphical editor. Interactive constraint-based search and replace can search for objects that obey user-specified sets of constraints and automatically apply other constraints to modify these objects. We show how an interactive tool that employs this technique makes it possible for users to define sets of constraints graphically that modify existing illustrations or control the creation of new illustrations. The interace uses the same visual language as the editor and allows users to understand and create powerful rules without conventional programming. Rules can be saved and retrieved for use alone or in combination. Examples, generated with a working implementation, demonstrate applications to drawing beautification and transformation.",
      "URL": "https://doi.org/10.1145/142750.143053",
      "DOI": "10.1145/142750.143053",
      "ISBN": "978-0-89791-513-5",
      "author": [
        {
          "family": "Kurlander",
          "given": "David"
        },
        {
          "family": "Feiner",
          "given": "Steven"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1992",
            6,
            1
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            15
          ]
        ]
      }
    }
  ],
  "1993": [
    {
      "id": "9296070/J6WNHTXX",
      "type": "paper-conference",
      "title": "Hyperform: using extensibility to develop dynamic, open, and distributed hypertext systems",
      "container-title": "Proceedings of the ACM conference on Hypertext",
      "collection-title": "ECHT '92",
      "publisher": "Association for Computing Machinery",
      "publisher-place": "New York, NY, USA",
      "page": "251–261",
      "event-place": "New York, NY, USA",
      "abstract": "An approach to flexible hyperbase (hypertext database) support predicated on the notion of ex-tensibility is presented. The extensible hypertext platform (Hyperform) implements basic hyperbase services that can be tailored to provide specialised hyperbase support. Hypeeform is based on an inter-nal computational engine that provides an object-oriented extension language which allows new data model objects and operations to be added at run-time. Hyperform has a number of built-in classes to pro-vide basic hyperbase features such as concurrency control, notification control (events), access control, version control and search and query. Each of these classes can be specialised using multiple inheritance to form virtually any type of hyperbase support needed in next-generation hypertext systems. This approach greatly reduces the effort required to provide high-quality customized hyperbase support for distributed hypertext applications. Hyper-form is implemented and operational in Unix environments. This paper describes the Hyperform approach, discusses its advantages and disadvantages, and gives examples of simulating the 11AM and the Danish Hyperlime in Hyperform. Hyper-form is compared with related work from the HAM generation of hyperbase systems and the current status of the project is reviewed.",
      "URL": "https://doi.org/10.1145/168466.171510",
      "DOI": "10.1145/168466.171510",
      "ISBN": "978-0-89791-547-X",
      "shortTitle": "Hyperform",
      "author": [
        {
          "family": "Wiil",
          "given": "Uffe K."
        },
        {
          "family": "Leggett",
          "given": "John J."
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1993",
            12,
            1
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            15
          ]
        ]
      }
    },
    {
      "id": "9296070/6L8UHVSY",
      "type": "article-journal",
      "title": "Isolation and analysis of optimization errors",
      "container-title": "ACM SIGPLAN Notices",
      "page": "26–35",
      "volume": "28",
      "issue": "6",
      "abstract": "This paper describes two related tools developed to support the isolation and analysts of optimization errors in the vpo optimizer. Both tools rely on vpo identifying sequences of changes, referred to as transformations. that result in semantically equivalent (and usually improved) code. One tool determines the first transfer. motion that causes incorrect output of the execution of the compiled program. This tool not only automatically isolates the illegal transformation, but also identifies the location and instant the transformation is performed in vpo. To assist in the analysis of an optimization error, a graphical optimization viewer was also implemented that can display the state of the generated instructions before and after each transformation performed by vpo. Unique features of the optimization viewer include reverse viewing (or undoing) of transformations and the ability to stop at breakpoints associated with the generated instructions. Both tools are useful independently. Together these tools form a powerful environment for facilitating the retargeting of vpo to a new machine and supporting experimentation with new optimizations. In addition, the optimization viewercan be used as a teaching aid in compiler classes.",
      "URL": "https://doi.org/10.1145/173262.155093",
      "DOI": "10.1145/173262.155093",
      "journalAbbreviation": "SIGPLAN Not.",
      "author": [
        {
          "family": "Boyd",
          "given": "Mickey R."
        },
        {
          "family": "Whalley",
          "given": "David B."
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1993",
            6,
            1
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            6,
            3
          ]
        ]
      }
    }
  ],
  "1994": [
    {
      "id": "9296070/CI5AB787",
      "type": "patent",
      "title": "Iterative technique for phrase query formation and an information retrieval...",
      "abstract": "An information retrieval system and method are provided in which an operator inputs one or more query words which are used to determine a search key for searching through a corpus of documents, and which returns any matches between the search key and the corpus of documents as a phrase containing the word data matching the query word(s), a non-stop (content) word next adjacent to the matching word data, and all intervening stop-words between the matching word data and the next adjacent non-stop word. The operator, after reviewing one or more of the returned phrases can then use one or more of the next adjacent non-stop-words as new query words to reformulate the search key and perform a subsequent search through the document corpus. This process can be conducted iteratively, until the appropriate documents of interest are located. The additional non-stop-words from each phrase are preferably aligned with each other (e.g., by columnation) to ease viewing of the \"new\" content words.",
      "URL": "https://patents.google.com/patent/US5278980A",
      "number": "US5278980A",
      "author": [
        {
          "family": "Jan O. Pedersen",
          "given": ""
        },
        {
          "family": "Per-Kristian Halvorsen",
          "given": ""
        },
        {
          "family": "Douglass R. Cutting",
          "given": ""
        },
        {
          "family": "John W. Tukey",
          "given": ""
        },
        {
          "family": "Eric A. Bier",
          "given": ""
        },
        {
          "family": "Daniel G. Bobrow",
          "given": ""
        }
      ],
      "issued": {
        "date-parts": [
          [
            1994,
            1,
            11
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            16
          ]
        ]
      }
    },
    {
      "id": "9296070/ELBQRBKS",
      "type": "patent",
      "title": "Text-compression technique using frequency-ordered array of word-number mappers",
      "abstract": "A text-compression technique utilizes a plurality of word-number mappers (\"WNMs\") in a frequency-ordered hierarchical structure. The particular structure of the set of WNMs depends on the specific encoding regime, but can be summarized as follows. Each WNM in the set is characterized by an ordinal WNM number and a WNM size (maximum number of tokens) that is in general a non-decreasing function of the WNM number. A given token is assigned a number pair, the first being one of the WNM numbers, and the second being the token's position or number in that WNM. Typically, the most frequently occurring tokens are mapped with a smaller-numbered WNM. The set of WNMs is generated on a first pass through the database to be compressed. The database is parsed into tokens, and a rank-order list based on the frequency of occurrence is generated. This list is partitioned in a manner to define the set of WNMs. Actual compression of the data base occurs on a second pass, using the set of WNMs generated on the first pass. The database is parsed into tokens, and for each token, the set of WNMs is searched to find the token. Once the token is found, it is assigned the appropriate number pair and is encoded. This proceeds until the entire database has been compressed.",
      "URL": "https://patents.google.com/patent/US5325091A/en",
      "number": "US5325091A",
      "author": [
        {
          "family": "Kaplan",
          "given": "Ronald M."
        },
        {
          "family": "Maxwell",
          "given": "John T. III"
        }
      ],
      "issued": {
        "date-parts": [
          [
            1994,
            6,
            28
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            6,
            1
          ]
        ]
      }
    }
  ],
  "1995": [
    {
      "id": "9296070/A52363YK",
      "type": "article-journal",
      "title": "Rich interaction in the digital library",
      "container-title": "Communications of the ACM",
      "page": "29-39",
      "volume": "38",
      "issue": "4",
      "abstract": "Effective information access involves rich interactions between users and information residing in diverse locations. Users seek and retrieve information from the sources—for example, file serves, databases, and digital libraries—and use various tools to browse, manipulate, reuse, and generally process the information. We have developed a number of techniques that support various aspects of the process of user/information interaction. These techniques can be considered attempts to increase the bandwidth and quality of the interactions between users and information in an information workspace—an environment designed to support information work (see Figure 1).",
      "URL": "https://doi.org/10.1145/205323.205326",
      "DOI": "10.1145/205323.205326",
      "journalAbbreviation": "Commun. ACM",
      "author": [
        {
          "family": "Rao",
          "given": "Ramana"
        },
        {
          "family": "Pedersen",
          "given": "Jan O."
        },
        {
          "family": "Hearst",
          "given": "Marti A."
        },
        {
          "family": "Mackinlay",
          "given": "Jock D."
        },
        {
          "family": "Card",
          "given": "Stuart K."
        },
        {
          "family": "Masinter",
          "given": "Larry"
        },
        {
          "family": "Halvorsen",
          "given": "Per-Kristian"
        },
        {
          "family": "Robertson",
          "given": "George C."
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1995",
            4,
            1
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            25
          ]
        ]
      }
    },
    {
      "id": "9296070/HFRDQ97U",
      "type": "article-journal",
      "title": "Freeing the essence of a computation",
      "container-title": "ACM SIGPLAN Lisp Pointers",
      "page": "25-36",
      "volume": "VIII",
      "issue": "2",
      "abstract": "In theory, abstraction is important, but in practice, so is performance. Thus, there is a struggle between an abstract description of an algorithm and its efficient implementation. This struggle can be mediated by using an interpreter or a compiler. An interpreter takes a program that is a high level abstract description of an algorithm and applies it to some data. Don't think of an interpreter as slow. An interpreter is important enough to software that it is often implemented in hardware. A compiler takes the program and produces another program, perhaps in another language. The resulting program is applied to some data by another interpreter.",
      "URL": "https://dl.acm.org/doi/10.1145/224133.224136",
      "DOI": "10.1145/224133.224136",
      "journalAbbreviation": "SIGPLAN Lisp Pointers",
      "language": "en",
      "author": [
        {
          "family": "Anderson",
          "given": "Kenneth R."
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1995",
            5,
            5
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            25
          ]
        ]
      }
    },
    {
      "id": "9296070/6L976844",
      "type": "article-journal",
      "title": "Ambitious evaluation: a new reading of an old issue",
      "container-title": "ACM SIGPLAN Lisp Pointers",
      "page": "1-44",
      "volume": "VIII",
      "issue": "2",
      "abstract": "Much has been written about Lazy Evaluation in Lisp---less about the other end of the spectrum---Ambitious Evaluation. Ambition is a very subjective concept, though, and if you have some preconceived idea of what you think an Ambitious Evaluator might be about, you might want to set it aside for a few minutes because this probably isn't going to be what you expect.",
      "URL": "https://dl.acm.org/doi/10.1145/224133.224137",
      "DOI": "10.1145/224133.224137",
      "shortTitle": "Ambitious evaluation",
      "journalAbbreviation": "SIGPLAN Lisp Pointers",
      "language": "en",
      "author": [
        {
          "family": "Pitman",
          "given": "Kent M."
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1995",
            5,
            5
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            25
          ]
        ]
      }
    }
  ],
  "1998": [
    {
      "id": "9296070/ZRI4MHTQ",
      "type": "article-journal",
      "title": "A conversation with Austin Henderson",
      "container-title": "Interactions",
      "page": "36–47",
      "volume": "5",
      "issue": "6",
      "URL": "https://doi.org/10.1145/287821.287827",
      "DOI": "10.1145/287821.287827",
      "journalAbbreviation": "interactions",
      "author": [
        {
          "family": "Ehrlich",
          "given": "Kate"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1998",
            11,
            1
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            15
          ]
        ]
      }
    }
  ],
  "2001": [
    {
      "id": "9296070/XMCBCFMT",
      "type": "chapter",
      "title": "On CAST.FSM Computation of Hierarchical Multi-layer Networks of Automata",
      "container-title": "Computer Aided Systems Theory — EUROCAST 2001",
      "publisher": "Springer Berlin Heidelberg",
      "publisher-place": "Berlin",
      "page": "36-44",
      "volume": "2178",
      "event-place": "Berlin",
      "abstract": "CAST.FSM denotes a CAST tool which has been developed at the Institute of Systems Science at the University of Linz during the years 1986–1993. The first version of CAST.FSM was implemented in INTERLISP-D and LOOPS for the Siemens-Xerox workstation 5815 (“Dandelion”). CAST.FSM supports the application of the theory of finite state machines for hardware design tasks between the architecture level and the level of gate circuits. The application domain, to get practical experience for CAST.FSM, was the field of VLSI design of ASICS’s where the theory of finite state machines can be applied to improve the testability of such circuits (“design for testability”) and to optimise the required silicon area of the circuit (“floor planning”). An overview of CAST as a whole and of CAST.FSM as a CAST tool is given in [11]. In our presentation we want to report on the re-engineering of CAST.FSM and on new types of applications of CAST.FSM which are currently under investigation. In this context we will distinguish between three different problems:\n1.\nthe implementation of CAST.FSM in ANSI Common Lisp and the design of a new user interface by Rudolf Mittelmann [5].\n\n \n2.\nthe search for systemstheoretical concepts in modelling intelligent hierarchical systems based on the past work of Arthur Koestler [3] following the concepts presented by Franz Pichler in [10].\n\n \n3.\nthe construction of hierarchical formal models (of multi-layer type) to study attributes which are assumed for SOHO-structures (SOHO = Self Organizing Hierarchical Order) of A. Koestler.\n\n \nThe latter problem will deserve the main attention in our presentation. In the present paper we will build such a hierarchical model following the concepts of parallel decomposition of finite state machines (FSMs) and interpret it as a multi-layer type of model.",
      "URL": "http://link.springer.com/10.1007/3-540-45654-6_3",
      "ISBN": "978-3-540-42959-3 978-3-540-45654-4",
      "note": "Series Title: Lecture Notes in Computer Science\nDOI: 10.1007/3-540-45654-6_3",
      "language": "en",
      "collection-editor": [
        {
          "family": "Goos",
          "given": "Gerhard"
        },
        {
          "family": "Hartmanis",
          "given": "Juris"
        },
        {
          "family": "van Leeuwen",
          "given": "Jan"
        }
      ],
      "editor": [
        {
          "family": "Moreno-Díaz",
          "given": "Roberto"
        },
        {
          "family": "Buchberger",
          "given": "Bruno"
        },
        {
          "family": "Luis Freire",
          "given": "José"
        }
      ],
      "author": [
        {
          "family": "Affenzeller",
          "given": "Michael"
        },
        {
          "family": "Pichler",
          "given": "Franz"
        },
        {
          "family": "Mittelmann",
          "given": "Rudolf"
        }
      ],
      "issued": {
        "date-parts": [
          [
            2001
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            15
          ]
        ]
      }
    }
  ],
  "2003": [
    {
      "id": "9296070/IVA8R7A2",
      "type": "report",
      "title": "Programming Languages -- The LOOPS Project (1982-1986)",
      "publisher": "Xerox Parc",
      "abstract": "The LOOPS (Lisp Object-Oriented Language) project was started to support development of expert systems project at PARC. We wanted a language that had many of the\nfeatures of frame languages, such as objects, annotated values, inheritance, and attached procedures. We drew heavily on Smalltalk-80, which was being developed next door.",
      "URL": "https://larrymasinter.net/stefik-loops.pdf",
      "language": "en",
      "author": [
        {
          "family": "Bobrow",
          "given": "Daniel"
        },
        {
          "family": "Mittal",
          "given": "Sanjay"
        },
        {
          "family": "Lanning",
          "given": "Stanley"
        },
        {
          "family": "Stefik",
          "given": "Mark"
        }
      ],
      "issued": {
        "date-parts": [
          [
            2003
          ]
        ]
      }
    },
    {
      "id": "9296070/IVA8R7A2",
      "type": "report",
      "title": "Programming Languages -- The LOOPS Project (1982-1986)",
      "publisher": "Xerox Parc",
      "abstract": "The LOOPS (Lisp Object-Oriented Language) project was started to support development of expert systems project at PARC. We wanted a language that had many of the\nfeatures of frame languages, such as objects, annotated values, inheritance, and attached procedures. We drew heavily on Smalltalk-80, which was being developed next door.",
      "URL": "https://larrymasinter.net/stefik-loops.pdf",
      "language": "en",
      "author": [
        {
          "family": "Bobrow",
          "given": "Daniel"
        },
        {
          "family": "Mittal",
          "given": "Sanjay"
        },
        {
          "family": "Lanning",
          "given": "Stanley"
        },
        {
          "family": "Stefik",
          "given": "Mark"
        }
      ],
      "issued": {
        "date-parts": [
          [
            2003
          ]
        ]
      }
    },
    {
      "id": "9296070/IVA8R7A2",
      "type": "report",
      "title": "Programming Languages -- The LOOPS Project (1982-1986)",
      "publisher": "Xerox Parc",
      "abstract": "The LOOPS (Lisp Object-Oriented Language) project was started to support development of expert systems project at PARC. We wanted a language that had many of the\nfeatures of frame languages, such as objects, annotated values, inheritance, and attached procedures. We drew heavily on Smalltalk-80, which was being developed next door.",
      "URL": "https://larrymasinter.net/stefik-loops.pdf",
      "language": "en",
      "author": [
        {
          "family": "Bobrow",
          "given": "Daniel"
        },
        {
          "family": "Mittal",
          "given": "Sanjay"
        },
        {
          "family": "Lanning",
          "given": "Stanley"
        },
        {
          "family": "Stefik",
          "given": "Mark"
        }
      ],
      "issued": {
        "date-parts": [
          [
            2003
          ]
        ]
      }
    }
  ],
  "2006": [
    {
      "id": "9296070/88GP5KT3",
      "type": "webpage",
      "title": "PDP-10 software archive",
      "URL": "http://pdp-10.trailing-edge.com/",
      "shortTitle": "Tape Images from Computer History",
      "author": [
        {
          "family": "Kossow",
          "given": "Al"
        }
      ],
      "issued": {
        "date-parts": [
          [
            2006
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            25
          ]
        ]
      }
    }
  ],
  "2008": [
    {
      "id": "9296070/DVGRZ62H",
      "type": "paper-conference",
      "title": "History of Interlisp",
      "container-title": "Celebrating the 50th Anniversary of Lisp",
      "collection-title": "LISP50",
      "publisher": "Association for Computing Machinery",
      "publisher-place": "New York, NY, USA",
      "page": "1–5",
      "event-place": "New York, NY, USA",
      "abstract": "I was first introduced to Lisp in 1962 as a first year graduate student at M.I.T. in a class taught by James Slagle. Having programmed in Fortran and assembly, I was impressed with Lisp's elegance. In particular, Lisp enabled expressing recursion in a manner that was so simple that many first time observers would ask the question, \"Where does the program do the work?\" (Answer - between the parentheses!) Lisp also provided the ability to manipulate programs, since Lisp programs were themselves data (S-expressions) the same as other list structures used to represent program data. This made Lisp an ideal language for writing programs that themselves constructed programs or proved things about programs. Since I was at M.I.T. to study Artificial Intelligence, program writing programs was something that interested me greatly.",
      "URL": "https://doi.org/10.1145/1529966.1529971",
      "DOI": "10.1145/1529966.1529971",
      "ISBN": "978-1-60558-383-9",
      "author": [
        {
          "family": "Teitelman",
          "given": "Warren"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "2008",
            10,
            20
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            15
          ]
        ]
      }
    }
  ],
  "2011": [
    {
      "id": "9296070/PUPZYPIV",
      "type": "motion_picture",
      "title": "The Colab Movie (1987)",
      "abstract": "The Colab project at PARC was an experiment in creating an electronic meeting room. This project developed multi-user interfaces, telepointers, and other innovations at the time. This movie shows the Cognoter tool which was a multi-user brainstorming tool used for collaborative development of an outline for a paper. See /www.markstefik.com/?page_id=155\"",
      "URL": "https://www.youtube.com/watch?v=iPZTOosKjAE",
      "shortTitle": "The Colab Movie",
      "author": [
        {
          "family": "Mark Stefik",
          "given": ""
        }
      ],
      "issued": {
        "date-parts": [
          [
            2011,
            4,
            10
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            5,
            17
          ]
        ]
      }
    },
    {
      "id": "9296070/MJP8UYEV",
      "type": "motion_picture",
      "title": "Truckin Knowledge Competition (1983)",
      "abstract": "In 1983 the Knowledge Systems Area at Xerox PARC taught experimental courses on knowledge programming. The Truckin' knowledge competition was the final exam at the end of a one week course. Students programmed their trucks to compete in Truckin' simulation world -- buying and selling goods, getting gas as needed, avoiding bandits, and so on. All of the trucks competed in the final. The winner was the truck with the most cash parked nearest Alice's Restaurant. See www.markstefik.com/?page_id=359",
      "URL": "https://www.youtube.com/watch?v=Pt-Sv1ynGKc",
      "author": [
        {
          "family": "Mark Stefik",
          "given": ""
        }
      ],
      "issued": {
        "date-parts": [
          [
            2011,
            4,
            10
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            5,
            17
          ]
        ]
      }
    }
  ],
  "2012": [
    {
      "id": "9296070/ZE7EVJYM",
      "type": "motion_picture",
      "title": "Graphical Programming (1988) - Part 0",
      "publisher": "Xerox Lisp Workstation",
      "abstract": "Guy DesVignes and R. Wayne Oldford, 1988 \n \nThis video (in 3 pieces) describes the use of graphical programming with an example, showing the encapsulation of several steps of an analysis into a single reusable tool.   An INTERLISP-D programming environment with the object oriented system LOOPS is used for software development. \nWork is on a Xerox Lisp Workstation  (Xerox 1186). \n \nFirst of 3 pieces of a single video. \n \nFirst piece: Graphical Programming (1988) - Part 0 \n       Contains: \n        \"Opening\"   \n            -  Introduction by a young Wayne Oldford   \n               (refers to earlier video called \"Data Analysis Networks \n                in DINDE\")  \n       \"Part 0 Statistical Analysis Maps\" \n            - review of the interactive data analysis network representation  \n              of a statistical analysis. \n \nSecond piece:  Graphical Programming (1988) - Parts 1 and 2 \n       Contains: \n        \"Part 1   Toolboxes\"   \n            -  Review of the elements of a statistical toolbox in DINDE  \n       \"Part 2 The Analysis Path\" \n            - Demonstrates exploration of a path in an existing \n              analysis map and its representation as a pattern, \n              It is shown how to capture this pattern in DINDE as a new \n             new program represented as an \"AnalysisPath\" object.. \n              This is what is meant by  \"graphical programming\". \n \n \nThird piece: \"Graphical Programming (1988) - Part 3\" \n       Contains: \n        \"Part 3   Graphical Programming \n                        Example: Added Variable Plots\"   \n            - Demonstrates graphical programming by constructing \n              an added variable plot.  This is done by constructing the \n              appropriate analysis path on some data, capturing the pattern \n              adding it to the toolbox and then applying it to new data. \n \n        \"Summary\" \n \n \nSound has been cleaned up a little. \nComplete video also available in whole at  \n        stat-graphics.org/movies/graphical-programming.html",
      "URL": "https://www.youtube.com/watch?v=J4F6ioMKiqw&t=53s",
      "author": [
        {
          "family": "Oldford",
          "given": "Wayne"
        }
      ],
      "issued": {
        "date-parts": [
          [
            2012,
            2,
            16
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            5,
            2
          ]
        ]
      }
    },
    {
      "id": "9296070/FJ2M3GNL",
      "type": "motion_picture",
      "title": "Graphical Programming (1988) - Parts 1 and 2",
      "publisher": "Xerox Lisp Workstation",
      "abstract": "Guy DesVignes and R. Wayne Oldford, 1988 \n \nThis video (in 3 pieces) describes the use of graphical programming with an example, showing the encapsulation of several steps of an analysis into a single reusable tool.   An INTERLISP-D programming environment with the object oriented system LOOPS is used for software development. \nWork is on a Xerox Lisp Workstation  (Xerox 1186). \n \nSecond of 3 pieces of a single video. \n \nFirst piece: Graphical Programming (1988) - Part 0 \n       Contains: \n        \"Opening\"   \n            -  Introduction by Wayne Oldford   \n               (refers to earlier video called \"Data Analysis Networks \n                in DINDE\")  \n       \"Part 0 Statistical Analysis Maps\" \n            - review of the interactive data analysis network representation  \n              of a statistical analysis. \n \nSecond piece:  Graphical Programming (1988) - Parts 1 and 2 \n       Contains: \n        \"Part 1   Toolboxes\"   \n            -  Review of the elements of a statistical toolbox in DINDE  \n       \"Part 2 The Analysis Path\" \n            - Demonstrates exploration of a path in an existing \n              analysis map and its representation as a pattern, \n              It is shown how to capture this pattern in DINDE as a new \n             new program represented as an \"AnalysisPath\" object.. \n              This is what is meant by  \"graphical programming\". \n \n \nThird piece: \"Graphical Programming (1988) - Part 3\" \n       Contains: \n        \"Part 3   Graphical Programming \n                        Example: Added Variable Plots\"   \n            - Demonstrates graphical programming by constructing \n              an added variable plot.  This is done by constructing the \n              appropriate analysis path on some data, capturing the pattern \n              adding it to the toolbox and then applying it to new data. \n \n        \"Summary\" \n \n \nSound has been cleaned up a little. \nComplete video also available in whole at  \n        stat-graphics.org/movies/graphical-programming.html",
      "URL": "https://www.youtube.com/watch?v=wlN0hHLZL8c",
      "author": [
        {
          "family": "Oldford",
          "given": "Wayne"
        }
      ],
      "issued": {
        "date-parts": [
          [
            2012,
            2,
            17
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            5,
            2
          ]
        ]
      }
    },
    {
      "id": "9296070/TEHSJNIS",
      "type": "motion_picture",
      "title": "Computer-Assisted Instruction (Bits and Bytes, Episode 7)",
      "abstract": "This clip looks at two examples of larger tutorial--CAI systems that were developed by the Ontario Institute for Studies and Education, and Xerox's PARC.\n\nIt is from Episode 7 of the classic 1983 television series, Bits and Bytes, which starred Luba Goy and Billy Van.  It was produced by TVOntario, but is no longer available for purchase.",
      "URL": "https://www.youtube.com/watch?v=eURtTV_qKw8&t=147s",
      "issued": {
        "date-parts": [
          [
            2012,
            5,
            19
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            5,
            2
          ]
        ]
      }
    }
  ],
  "2017": [
    {
      "id": "9296070/S2ZC62QX",
      "type": "webpage",
      "title": "Interlisp-D at AAAI-82",
      "container-title": "Google Photos",
      "abstract": "17 new photos added to shared album",
      "URL": "https://photos.google.com/share/AF1QipORUrk2uwraYYJVOZ2R8mH51U4n5uv30V1KJk5zvu5Pd5XtEXuXp8jg1BfwdHBHkw?key=OGxZSU5LbXZPaTdmbnU3QmZiOTRlYnR6SDdMNUJ3",
      "language": "en",
      "author": [
        {
          "family": "Masinter",
          "given": "Larry"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "2017",
            9,
            30
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            16
          ]
        ]
      }
    }
  ],
  "2020": [
    {
      "id": "9296070/XK2RYFWN",
      "type": "book",
      "title": "livingcomputermuseum/Darkstar",
      "abstract": "A Xerox Star 8010 Emulator. Contribute to livingcomputermuseum/Darkstar development by creating an account on GitHub.",
      "URL": "https://github.com/livingcomputermuseum/Darkstar",
      "note": "original-date: 2019-01-15T20:40:02Z",
      "author": [
        {
          "family": "Museum+Labs",
          "given": "Living Computers:"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "2020",
            12,
            25
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            15
          ]
        ]
      }
    }
  ],
  "2021": [
    {
      "id": "9296070/JELN3BBL",
      "type": "entry-encyclopedia",
      "title": "Interlisp",
      "container-title": "Wikipedia",
      "abstract": "Interlisp (also seen with a variety of capitalizations) is a programming environment built around a version of the programming language Lisp. Interlisp development began in 1966 at Bolt, Beranek and Newman (renamed BBN Technologies) in Cambridge, Massachusetts with Lisp implemented for the Digital Equipment Corporation (DEC) PDP-1 computer by Danny Bobrow and D. L. Murphy. In 1970, Alice K. Hartley implemented BBN LISP, which ran on PDP-10 machines running the operating system TENEX (renamed TOPS-20). In 1973, when Danny Bobrow, Warren Teitelman and Ronald Kaplan moved from BBN to the Xerox Palo Alto Research Center (PARC), it was renamed Interlisp. Interlisp became a popular Lisp development tool for artificial intelligence (AI) researchers at Stanford University and elsewhere in the community of the Defense Advanced Research Projects Agency (DARPA). Interlisp was notable for integrating interactive development tools into an integrated development environment (IDE), such as a debugger, an automatic correction tool for simple errors (via do what I mean (DWIM) software design, and analysis tools.",
      "URL": "https://en.wikipedia.org/w/index.php?title=Interlisp&oldid=1014034897",
      "language": "en",
      "editor": [
        {
          "family": "Jekkara",
          "given": ""
        }
      ],
      "issued": {
        "date-parts": [
          [
            "2021",
            3,
            24
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            21
          ]
        ]
      }
    },
    {
      "id": "9296070/RCFRZY85",
      "type": "article-journal",
      "title": "An Archive of Interfaces: Exploring the Potential of Emulation for Software Research, Pedagogy, and Design",
      "container-title": "Proceedings of the ACM on Human-Computer Interaction",
      "page": "294:1–294:22",
      "volume": "5",
      "issue": "CSCW2",
      "abstract": "This paper explores the potential of distributed emulation networks to support research and pedagogy into historical and sociotechnical aspects of software. Emulation is a type of virtualization that re-creates the conditions for a piece of legacy software to operate on a modern system. The paper first offers a review of Computer-Supported Cooperative Work (CSCW), Human-Computer Interaction (HCI), and Science and Technology Studies (STS) literature engaging with software as historical and sociotechnical artifacts, and with emulation as a vehicle of scholarly inquiry. It then documents the novel use of software emulations as a pedagogical resource and research tool for legacy software systems analysis. This is accomplished through the integration of the Emulation as a Service Infrastructure (EaaSI) distributed emulation network into a university-level course focusing on computer-aided design (CAD). The paper offers a detailed case study of a pedagogical experience oriented to incorporate emulations into software research and learning. It shows how emulations allow for close, user-centered analyses of software systems that highlight both their historical evolution and core interaction concepts, and how they shape the work practices of their users.",
      "URL": "https://doi.org/10.1145/3476035",
      "DOI": "10.1145/3476035",
      "shortTitle": "An Archive of Interfaces",
      "journalAbbreviation": "Proc. ACM Hum.-Comput. Interact.",
      "author": [
        {
          "family": "Cardoso-Llach",
          "given": "Daniel"
        },
        {
          "family": "Kaltman",
          "given": "Eric"
        },
        {
          "family": "Erdolu",
          "given": "Emek"
        },
        {
          "family": "Furste",
          "given": "Zachary"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "2021",
            10,
            18
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            10,
            21
          ]
        ]
      }
    }
  ],
  "1963": [
    {
      "id": "9296070/EIATQTVR",
      "type": "article-journal",
      "title": "A Heuristic Program that Solves Symbolic Integration Problems in Freshman Calculus",
      "container-title": "Journal of the ACM",
      "page": "413-581",
      "volume": "10",
      "issue": "4",
      "abstract": "A large high-speed general-purpose digital computer (IBM 7090) was programmed to solve elementary symbolic integration problems at approximately the level of a good college freshman. The program is called SAINT, an acronym for \"Symbolic Automatic INTegrator.\" This paper discusses the SAINT program and its performance. SAINT performs indefinite integration. It also performs definite and multiple integration when these are trivial extensions of indefinite integration. It uses many of the methods and heuristics of students attacking the same prombles. SAINT took an average of two minutes each to solve 52 of the 54 attempted problems taken from the Massachusetts Institute of Technology freshman calculus final examinations. Based on this and other experiments with SAINT, some conclusions coneering computer solution of such problems are: (1) Pattern recognition is of fundamental importance. (2) Great benefit would have been derived from a large memory and more convenient symbol manipulating facilities. (3) The solution of a symbolic integration problem by a commercially available computer is far cheaper and faster than by man.",
      "URL": "https://dl.acm.org/doi/10.1145/321186.321193",
      "DOI": "10.1145/321186.321193",
      "journalAbbreviation": "J. ACM",
      "language": "en",
      "author": [
        {
          "family": "Slagle",
          "given": "James R."
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1963",
            10
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            25
          ]
        ]
      }
    }
  ],
  "1965": [
    {
      "id": "9296070/RTRAYUTG",
      "type": "article",
      "title": "930 LISP Reference Manual",
      "URL": "http://bitsavers.org/pdf/sds/9xx/940/ucbProjectGenie/30.50.40_930_LISP_Reference_Feb66.pdf",
      "language": "English",
      "author": [
        {
          "family": "Deutsch",
          "given": "L. Peter"
        },
        {
          "family": "Lampson",
          "given": "Butler W."
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1965",
            6,
            5
          ]
        ]
      }
    }
  ],
  "1968": [
    {
      "id": "9296070/DNCVYGJC",
      "type": "article-journal",
      "title": "A note on the efficiency of a LISP computation in a paged machine",
      "container-title": "Communications of the ACM",
      "page": "558",
      "volume": "11",
      "issue": "8",
      "abstract": "The problem of the use of two levels of storage for programs is explored in the context of a LISP system which uses core memory as a buffer for a large virtual memory stored on a drum. Details of timing are given for one particular problem.",
      "URL": "https://dl.acm.org/doi/10.1145/363567.363581",
      "DOI": "10.1145/363567.363581",
      "journalAbbreviation": "Commun. ACM",
      "language": "en",
      "author": [
        {
          "family": "Bobrow",
          "given": "Daniel G."
        },
        {
          "family": "Murphy",
          "given": "Daniel L."
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1968",
            8
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            21
          ]
        ]
      }
    }
  ],
  "1969": [
    {
      "id": "9296070/9SDF3BWD",
      "type": "book",
      "title": "The BBN-LISP system: Reference Manual",
      "publisher": "Bolt, Beranek and Newman Inc",
      "publisher-place": "Cambridge",
      "number-of-pages": "368",
      "event-place": "Cambridge",
      "abstract": "This document describes the BEN-LISP system currently implemented on the SDS 940. It is a dialect of LISP 1.5 and the differences between IBM 7090 version and this system are described in Appendix\n1 and 2. Principally, this system has been expanded from the LISP 1.5 on the 7090 in a number of different ways. BBN-LISP is\ndesigned to utilize a drum for storage and to provide the user a large virtual memory, with a relatively small penalty in speed (using special paging techniques described in Bobrow and Murphy 1967).",
      "URL": "http://www.bitsavers.org/pdf/bbn/The_BBN-LISP_System_Apr69.pdf",
      "call-number": "Z699.5.L28 B62 1969",
      "shortTitle": "The BBN-LISP system",
      "editor": [
        {
          "family": "Bobrow",
          "given": "Daniel G."
        },
        {
          "family": "Murphy",
          "given": "D. L."
        },
        {
          "family": "Teitelman",
          "given": "Warren"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1969",
            4
          ]
        ]
      }
    },
    {
      "id": "9296070/I2U8XT9Z",
      "type": "article-journal",
      "title": "LISP bulletin",
      "container-title": "ACM SIGPLAN Notices",
      "page": "17-57",
      "volume": "4",
      "issue": "9",
      "abstract": "This first (long delayed) LISP Bulletin contains samples of most of those types of items which the editor feels are relevant to this publication. These include announcements of new (i.e. not previously announced here) implementations of LISP (or closely related) systems; quick tricks in LISP; abstracts of LISP related papers; short writeups and listings of useful programs; and longer articles on problems of general interest to the entire LISP community. Printing of these last articles in the Bulletin does not interfere with later publications in formal journals or books. Short write-ups of new features added to LISP are of interest, preferably upward compatible with LISP 1.5, especially if they are illustrated by programming examples.",
      "URL": "https://doi.org/10.1145/1132291.1132032",
      "DOI": "10.1145/1132291.1132032",
      "journalAbbreviation": "SIGPLAN Not.",
      "author": [
        {
          "family": "Bobrow",
          "given": "D. G."
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1969",
            9,
            1
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            25
          ]
        ]
      }
    }
  ],
  "1971": [
    {
      "id": "9296070/JCVVQUVD",
      "type": "article",
      "title": "BBN - LISP, TENEX Reference Manual",
      "publisher": "Bolt, Beranek and Newman, Inc. (BBN)",
      "URL": "http://www.softwarepreservation.org/projects/LISP/bbnlisp/TenexLispRef_Jul71.pdf",
      "author": [
        {
          "family": "Teitelman",
          "given": "W."
        },
        {
          "family": "Bobrow",
          "given": "D. G."
        },
        {
          "family": "Hartley",
          "given": "A. K."
        },
        {
          "family": "Murphy",
          "given": "D. L."
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1971",
            7
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            6,
            1
          ]
        ]
      }
    }
  ],
  "1974": [
    {
      "id": "9296070/QQ4WARPF",
      "type": "article-journal",
      "title": "INTERLISP documentation",
      "container-title": "ACM SIGART Bulletin",
      "page": "5-22",
      "issue": "44",
      "abstract": "Documentation for INTERSLIP in the form of the INTERSLIP Reference Manual is now available and may be obtained from Warren Teitelman, Xerox Palo Alto Research Center. The new manual replaces all existing documentation, and is completely up to date (as to January, 1974). The manual is available in either loose-leaf or bound form. The lose-leaf version (binders not supplied) comes with printed separator tabs between the chapters. The bound version also includes colored divider pages between chapters, and is printed on somewhat thinner paper than the loose-leaf version, in an effort to make it 'portable' (the manual being approximately 700 pages long). Both versions contain a complete master index (approximately 1600 entries), as well as a separate index for each chapter. Although the manual is intended primarily to be used for reference, many chapters, e.g., the programmer's assistant, do-what-I-mean, CLISP, etc., include introductory and tutorial material. The manual is available in machine-readable form, and an on-line question-answering system using the manual as a data base is currently being implemented.",
      "URL": "https://doi.org/10.1145/1045183.1045186",
      "DOI": "10.1145/1045183.1045186",
      "journalAbbreviation": "SIGART Bull.",
      "author": [
        {
          "family": "Teitelman",
          "given": "Warren"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1974",
            2,
            1
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            15
          ]
        ]
      }
    },
    {
      "id": "9296070/K4LSMPDE",
      "type": "article",
      "title": "Display primitives in Lisp",
      "publisher": "Palo Alto Research Center, Xerox Corporation",
      "abstract": "Several conflicting goal must be resolved in deciding on a set of display facilities for Lisp: ease of lisp, efficient access to hardware facilities, and device and system independence. Thiss memo suggests a set of facilities constructed in two layers: a lower layer that gives direct access to the Alto\nbitmap capability, while retaining Lisp's tradition of freeing the programmer\nfrom  storage allocation worries and an upper Iayer that uses the lower (on the Alto) or a character-stream protocol (for VTS t on MAXC) to provide for writing strings, scrolling, edting, etc. on the screen,",
      "URL": "http://www.bitsavers.org/pdf/xerox/alto/memos_1974/Display_Primitives_in_Lisp_Nov74.pdf",
      "author": [
        {
          "family": "Deutsch",
          "given": "P."
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1974",
            11,
            18
          ]
        ]
      }
    }
  ],
  "1977": [
    {
      "id": "9296070/3H5F6TBA",
      "type": "paper-conference",
      "title": "A display oriented programmer's assistant",
      "container-title": "Proceedings of the 5th international joint conference on Artificial intelligence - Volume 2",
      "collection-title": "IJCAI'77",
      "publisher": "Morgan Kaufmann Publishers Inc.",
      "publisher-place": "San Francisco, CA, USA",
      "page": "905–915",
      "event-place": "San Francisco, CA, USA",
      "abstract": "This paper continues and extends previous work by the author in developing systems which provide the user with various forms of explicit and implicit assistance, and in general cooperate with the user in the development of his programs. The system described in this paper makes extensive use of a bit map display and pointing device (a mouse) to significantly enrich the user's interactions with the system, and to provide capabilities not possible with terminals that essentially emulate hard copy devices. For example, any text that is displayed on the screen can be pointed at and treated as input, exactly as though it were typed, i.e., the user can say use this expression or that value, and then simply point. The user views his programming environment through a collection of display windows, each of which corresponds to a different task or context. The user can manipulate the windows, or the contents of a particular window, by a combination of keyboard inputs or pointing operations. The technique of using different windows for different tasks makes it easy for the user to manage several simultaneous tasks and contexts, e.g., defining programs, testing programs, editing, asking the system for assistance, sending and receiving messages, etc and to switch back and forth between these tasks at his convenience.",
      "URL": "https://dl.acm.org/doi/10.5555/1622943.1623025",
      "author": [
        {
          "family": "Teitelman",
          "given": "Warren"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1977",
            8,
            22
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            5,
            31
          ]
        ]
      }
    },
    {
      "id": "9296070/P5MUCJX3",
      "type": "article-journal",
      "title": "Semantic grammar: an engineering technique for constructing natural language understanding systems",
      "container-title": "ACM SIGART Bulletin",
      "page": "26",
      "issue": "61",
      "abstract": "One of the major stumbling blocks to more effective used computers by naive users is the lack of natural means of communication between the user and the computer system. This report discusses a paradigm for constructing efficient and friendly man-machine interface systems involving subsets of natural language for limited domains of discourse. As such this work falls somewhere between highly constrained formal language query systems and unrestricted natural language under-standing systems. The primary purpose of this research is not to advance our theoretical under-standing of natural language but rather to put forth a set of techniques for embedding both semantic/conceptual and pragmatic information into a useful natural language interface module. Our intent has been to produce a front end system which enables the user to concentrate on his problem or task rather than making him worry about how to communicate his ideas or questions to the machine.",
      "URL": "https://doi.org/10.1145/1045283.1045290",
      "DOI": "10.1145/1045283.1045290",
      "shortTitle": "Semantic grammar",
      "journalAbbreviation": "SIGART Bull.",
      "language": "en",
      "author": [
        {
          "family": "Burton",
          "given": "Richard R."
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1977",
            2,
            1
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            6,
            2
          ]
        ]
      }
    },
    {
      "id": "9296070/S82MS337",
      "type": "report",
      "title": "INTERLISP DISPLAY PRIMITIVES",
      "publisher-place": "Xerox Palo Alto Research Center3333 Coyote H iII RoadPalo Altot California 94304",
      "event-place": "Xerox Palo Alto Research Center3333 Coyote H iII RoadPalo Altot California 94304",
      "abstract": "This report describes briefly a set of display primitives that we have developed at PARC toextend the capabilities of InterLisp[l]. These primitives are designed to operate araster-scanned displaYt and concentrate on facilities for placing text carefully on the displayand for moving chunks of an already-created display.",
      "URL": "http://scholar.googleusercontent.com/scholar?q=cache:fAjwtL8R9ogJ:scholar.google.com/+INTERLISP+DISPLAY+PRIl%5ClITIVES&hl=en&as_sdt=0,5",
      "language": "en-US",
      "author": [
        {
          "family": "Sproull",
          "given": "Robert F."
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1977",
            7
          ]
        ]
      }
    }
  ],
  "1989": [
    {
      "id": "9296070/GPMCN5XC",
      "type": "paper-conference",
      "title": "The PepPro™ Peptide Synthesis Expert System",
      "container-title": "PROCEEDINGS OF THE FIRST ANNUAL CONFERENCE ON INNOVATIVE APPLICATIONS OF ARTIFICIAL INTELLIGENCE",
      "publisher": "The AAAI Press, Menlo Park, California",
      "publisher-place": "Stanford, California",
      "event": "THE FIRST ANNUAL CONFERENCE ON INNOVATIVE APPLICATIONS OF ARTIFICIAL INTELLIGENCE",
      "event-place": "Stanford, California",
      "abstract": "Peptide synthesis is an important research tool. However, successful syntheses require considerable effort from the scientist. We have produced an expert System, the PepPro™ Peptide Synthesis Expert System, that helps the scientist improve peptide syntheses. To use PepPro the scientist enters the peptide to be synthesized. PepPro then applies its synthesis rules to analyze the peptide, to predict coupling. problems, and to recommend solutions. PepPro produces a synthesis report that summarizes the analysis and recommendations. The program includes a capability that allows the scientist to write new synthesis rules and add them to the PepPro knowledge base. PepPro was developed on Xerox 11xx series workstations using Beckman’s proprietary development environment MP). We then compiled PepPro to run on the IBM PC. PepPro has limitations that derive from unpredictable events during a synthesis. Despite the limitations, PepPro provides several important benefits. The major one is that it makes peptide syntheses easier, less time-consuming, and more efficient.",
      "URL": "https://www.aaai.org/Papers/IAAI/1989/IAAI89-010.pdf",
      "author": [
        {
          "family": "Martz",
          "given": "Philip R."
        },
        {
          "family": "Heffron",
          "given": "Matt"
        },
        {
          "family": "Kalbag",
          "given": "Suresh"
        },
        {
          "family": "Dyckes",
          "given": "Douglas F."
        },
        {
          "family": "Voelker",
          "given": "Paul"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1989",
            3,
            28
          ]
        ]
      }
    }
  ],
  "1996": [
    {
      "id": "9296070/CHD59QIJ",
      "type": "article-journal",
      "title": "Cyberethics and the future of computing",
      "container-title": "ACM SIGCAS Computers and Society",
      "page": "22-29",
      "volume": "26",
      "issue": "2",
      "URL": "https://doi.org/10.1145/236394.236396",
      "DOI": "10.1145/236394.236396",
      "journalAbbreviation": "SIGCAS Comput. Soc.",
      "author": [
        {
          "family": "Tavani",
          "given": "Herman T."
        }
      ],
      "issued": {
        "date-parts": [
          [
            "1996",
            5,
            1
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            25
          ]
        ]
      }
    }
  ],
  "2007": [
    {
      "id": "9296070/4QGNIKFU",
      "type": "article-journal",
      "title": "Word play",
      "container-title": "Computational Linguistics",
      "page": "443–467",
      "volume": "33",
      "issue": "4",
      "abstract": "This article is a perspective on some important developments in semantics and in computational linguistics over the past forty years. It reviews two lines of research that lie at opposite ends of the field: semantics and morphology. The semantic part deals with issues from the 1970s such as discourse referents, implicative verbs, presuppositions, and questions. The second part presents a brief history of the application of finite-state transducers to linguistic analysis starting with the advent of two-level morphology in the early 1980s and culminating in successful commercial applications in the 1990s. It offers some commentary on the relationship, or the lack thereof, between computational and paper-and-pencil linguistics. The final section returns to the semantic issues and their application to currently popular tasks such as textual inference and question answering.",
      "URL": "https://doi.org/10.1162/coli.2007.33.4.443",
      "DOI": "10.1162/coli.2007.33.4.443",
      "journalAbbreviation": "Comput. Linguist.",
      "author": [
        {
          "family": "Karttunen",
          "given": "Lauri"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "2007",
            12,
            1
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            15
          ]
        ]
      }
    }
  ],
  "2010": [
    {
      "id": "9296070/IKAJUF8S",
      "type": "webpage",
      "title": "Medley",
      "container-title": "VENUE",
      "URL": "https://web.archive.org/web/20100304002925/http://top2bottom.net:80/medley.html",
      "author": [
        {
          "family": "Jill Marci Sybalsky",
          "given": ""
        }
      ],
      "issued": {
        "date-parts": [
          [
            "2010",
            3,
            4
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            21
          ]
        ]
      }
    }
  ],
  "2015": [
    {
      "id": "9296070/23ZCTJ9Z",
      "type": "article-journal",
      "title": "TENEX and TOPS-20",
      "container-title": "Annals of the History of Computing, IEEE",
      "page": "75-82",
      "volume": "37",
      "abstract": "In the late 1960s, a small group of developers at Bolt, Beranek, and Newman (BBN) in Cambridge, Massachusetts, began work on a new computer operating system, including a kernel, system call API, and user command interface (shell). While such an undertaking, particularly with a small group, became rare in subsequent decades, it was not uncommon in the 1960s. During development, this OS was given the name TENEX. A few years later, TENEX was adopted by Digital Equipment Corporation (DEC) for its new line of large machines to be known as the DECSYSTEM-20, and the operating system was renamed to TOPS-20. The author followed TENEX (or vice versa) on this journey, and these are some reflections and observations from that journey. He touches on some of the technical aspects that made TENEX notable in its day and an influence on operating systems that followed as well as on some of the people and other facets involved in the various steps along the way.",
      "URL": "https://www.researchgate.net/publication/273523084_TENEX_and_TOPS-20",
      "DOI": "10.1109/MAHC.2015.15",
      "note": "Publisher: IEEE",
      "journalAbbreviation": "Annals of the History of Computing",
      "author": [
        {
          "family": "Murphy",
          "given": "Dan"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "2015",
            1,
            1
          ]
        ]
      }
    },
    {
      "id": "9296070/THLV47EY",
      "type": "report",
      "title": "Emulation & Virtualization as Preservation Strategies",
      "publisher": "The Andrew W. Mellon Foundation",
      "author": [
        {
          "family": "Rosenthal",
          "given": "David S.H."
        }
      ],
      "issued": {
        "date-parts": [
          [
            "2015",
            10
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2016,
            1,
            23
          ]
        ]
      }
    }
  ],
  "2019": [
    {
      "id": "9296070/IRKEPIAR",
      "type": "post-weblog",
      "title": "Introducing Darkstar: A Xerox Star Emulator",
      "container-title": "Adafruit Industries - Makers, hackers, artists, designers and engineers!",
      "abstract": "Via libingcomputers.org: Josh Dersch writes about research into the Xerox 8010 Information System (codenamed “Dandelion” during development) and commonly referred to as the Star. The Star was envisioned as center point of the office of the future, combining high-resolution graphics with the now-familiar mouse, Ethernet networking for sharing and collaborating, and Xerox’s Laser Printer technology for faithful “WYSIWYG” document reproduction. A revolutionary system when most everyone else was using text based systems.",
      "URL": "https://blog.adafruit.com/2019/01/23/introducing-darkstar-a-xerox-star-emulator-vintagecomputing-xerox-emulation/",
      "shortTitle": "Introducing Darkstar",
      "language": "en-US",
      "author": [
        {
          "family": "Barela",
          "given": "Anne"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "2019",
            1,
            23
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            21
          ]
        ]
      }
    },
    {
      "id": "9296070/ETMY665Q",
      "type": "paper-conference",
      "title": "From NoteCards to Notebooks: There and Back Again",
      "container-title": "Proceedings of the 30th ACM Conference on Hypertext and Social Media",
      "collection-title": "HT '19",
      "publisher": "Association for Computing Machinery",
      "publisher-place": "New York, NY, USA",
      "page": "19–28",
      "event-place": "New York, NY, USA",
      "abstract": "Fifty years since the beginning of the Internet, and three decades of the Dexter Hypertext Reference Model and the World Wide Web mark an opportune time to take stock and consider how hypermedia has developed, and in which direction it might be headed. The modern Web has on one hand turned into a place where very few, very large companies control all major platforms with some highly unfortunately consequences. On the other hand, it has also led to the creation of a highly flexible and nigh ubiquitous set of technologies and practices, which can be used as the basis for future hypermedia research with the rise of computational notebooks as a prime example of a new kind of collaborative and highly malleable applications.",
      "URL": "https://doi.org/10.1145/3342220.3343666",
      "DOI": "10.1145/3342220.3343666",
      "ISBN": "978-1-4503-6885-8",
      "shortTitle": "From NoteCards to Notebooks",
      "author": [
        {
          "family": "Bouvin",
          "given": "Niels Olof"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "2019",
            9,
            12
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            15
          ]
        ]
      }
    },
    {
      "id": "9296070/ETMY665Q",
      "type": "paper-conference",
      "title": "From NoteCards to Notebooks: There and Back Again",
      "container-title": "Proceedings of the 30th ACM Conference on Hypertext and Social Media",
      "collection-title": "HT '19",
      "publisher": "Association for Computing Machinery",
      "publisher-place": "New York, NY, USA",
      "page": "19–28",
      "event-place": "New York, NY, USA",
      "abstract": "Fifty years since the beginning of the Internet, and three decades of the Dexter Hypertext Reference Model and the World Wide Web mark an opportune time to take stock and consider how hypermedia has developed, and in which direction it might be headed. The modern Web has on one hand turned into a place where very few, very large companies control all major platforms with some highly unfortunately consequences. On the other hand, it has also led to the creation of a highly flexible and nigh ubiquitous set of technologies and practices, which can be used as the basis for future hypermedia research with the rise of computational notebooks as a prime example of a new kind of collaborative and highly malleable applications.",
      "URL": "https://doi.org/10.1145/3342220.3343666",
      "DOI": "10.1145/3342220.3343666",
      "ISBN": "978-1-4503-6885-8",
      "shortTitle": "From NoteCards to Notebooks",
      "author": [
        {
          "family": "Bouvin",
          "given": "Niels Olof"
        }
      ],
      "issued": {
        "date-parts": [
          [
            "2019",
            9,
            12
          ]
        ]
      },
      "accessed": {
        "date-parts": [
          [
            2021,
            4,
            15
          ]
        ]
      }
    }
  ]
}
