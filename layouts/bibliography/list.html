{{ define "sidebar" }}{{ end }}
{{ define "main" }}

<header class="bib-header">
  <h1 class="bib-title">{{ or .Params.heading .Title }}</h1>

  <div class="bib-filter">
    <label for="itemTypeFilter">Filter by Type:</label>
    <select id="itemTypeFilter">
      <option value="all">All</option>
      {{ range $key, $value := .Site.Taxonomies.item_type }}
        <option value="{{ $key }}">{{ $key | title }}</option>
      {{ end }}
    </select>

 <!-- New: Year comparator + value -->
    <label for="yearCmp" style="margin-left:.75rem;">Year:</label>
    <select id="yearCmp">
      <option value="all">All</option>
      <option value="=">=</option>
      <option value=">">&gt;</option>
      <option value="<">&lt;</option>
      <option value=">=">&ge;</option>
      <option value="<=">&le;</option>
    </select>
    <input id="yearValue" type="number" min="0" step="1" style="width:6rem;" placeholder="YYYY">
  </div>
</header>

{{ .Content }}

<style>
  .bib-header {
    display: flex;
    align-items: baseline;
    justify-content: space-between;
    gap: 1rem;
    flex-wrap: wrap;
    margin-bottom: 1rem;
  }
  .bib-title { margin: 0; }
  ul.pub-list { list-style: none; margin: 0; padding: 0; }
  ul.pub-list > li { margin: 0; padding: .75rem 0; border-bottom: 1px solid #e2e2e2; }
  ul.pub-list > li:last-child { border-bottom: none; }
</style>

{{- $previewWordLimit := 24 -}}

{{- /* Get and sort pages */ -}}
{{ $pages := .RegularPages }}
{{- $pages = sort $pages "Date" "desc" -}}
{{- $pages = sort $pages "Title" "asc" -}}

{{- /* Build distinct list of years present (desc), track if any are undated */ -}}
{{- $years := slice -}}
{{- $seen := dict -}}
{{- $hasUndated := false -}}
{{- range $pages -}}
  {{- $d := .Date -}}
  {{- with .Params.date -}}
    {{- $iso := trim . " " -}}
    {{- if and (ne $iso "") (findRE `^\d{4}-\d{2}-\d{2}` $iso) -}}
      {{- $d = time $iso -}}
    {{- end -}}
  {{- end -}}
  {{- $y := $d.Format "2006" -}}
  {{- if eq $y "0001" -}}
    {{- $hasUndated = true -}}
  {{- else -}}
    {{- if not (isset $seen $y) -}}
      {{- $seen = merge $seen (dict $y true) -}}
      {{- $years = $years | append $y -}}
    {{- end -}}
  {{- end -}}
{{- end -}}
{{- warnf "Distinct years: %v (undated: %v)" $years $hasUndated -}}
{{- $years = sort $years -}}
{{- $years = $years | collections.Reverse -}}


<script>
document.addEventListener('DOMContentLoaded', function () {
  const typeSel   = document.getElementById('itemTypeFilter');
  const yearCmp   = document.getElementById('yearCmp');
  const yearInput = document.getElementById('yearValue');
  const items     = Array.from(document.querySelectorAll('#bibliographyList > li'));

  const getTypes = li => (li.dataset.type || '')
    .split(',').map(s => s.trim().toLowerCase()).filter(Boolean);
  const getYear = li => {
    const y = (li.dataset.year || '').toLowerCase();
    if (!y || y === 'undated') return null;
    const n = parseInt(y, 10);
    return Number.isNaN(n) ? null : n;
  };

  function matchYear(yearNum, cmp, valNum) {
    if (cmp === 'all') return true;
    if (yearNum === null || valNum === null) return false;
    switch (cmp) {
      case '=':  return yearNum === valNum;
      case '>':  return yearNum >  valNum;
      case '<':  return yearNum <  valNum;
      case '>=': return yearNum >= valNum;
      case '<=': return yearNum <= valNum;
      default: return true;
    }
  }

  function showHideItems() {
    const t = (typeSel.value || 'all').toLowerCase();
    const cmp = yearCmp.value;
    const valStr = yearInput.value.trim();
    const valNum = (/^\d{4}$/.test(valStr)) ? parseInt(valStr,10) : null;

    items.forEach(li => {
      const types = getTypes(li);
      const yrNum = getYear(li);
      const typeOK = (t === 'all') || types.includes(t);
      const yearOK = matchYear(yrNum, cmp, valNum);
      li.style.display = (typeOK && yearOK) ? '' : 'none';
    });
  }

  // Allow deep link (?item_type=foo&yearCmp=>=&year=1980)
  const params = new URLSearchParams(window.location.search);
  const qType = (params.get('item_type') || '').toLowerCase();
  if (qType && typeSel.querySelector(`option[value="${qType}"]`)) typeSel.value = qType;
  const qCmp  = params.get('yearCmp');
  if (qCmp && yearCmp.querySelector(`option[value="${qCmp}"]`)) yearCmp.value = qCmp;
  const qYear = params.get('year');
  if (qYear && /^\d{4}$/.test(qYear)) yearInput.value = qYear;

  typeSel.addEventListener('change', showHideItems);
  yearCmp.addEventListener('change', showHideItems);
  yearInput.addEventListener('input', showHideItems);

  showHideItems();
});
</script>

<ul class="pub-list" id="bibliographyList">
  {{ range $pages }}
    {{- /* item_type for type filter */ -}}
    {{- $types := "" -}}
    {{- with .Params.item_type -}}
      {{- if reflect.IsSlice . -}}
        {{- $types = delimit (apply . "lower" ".") "," -}}
      {{- else -}}
        {{- $types = (lower .) -}}
      {{- end -}}
    {{- end -}}

    {{- /* compute a year key for data-year */ -}}
    {{- $d := .Date -}}
    {{- $fmtDate := .Params.readabledate -}}
    {{- with .Params.date -}}
      {{- $iso := trim . " " -}}
      {{- if and (ne $iso "") (findRE `^\d{4}-\d{2}-\d{2}` $iso) -}}
        {{- $d = time $iso -}}
      {{- end -}}
    {{- end -}}
    {{- $year := $d.Format "2006" -}}
    {{- if eq $year "0001" -}}{{- $year = "undated" -}}{{- end -}}

    <li class="pub-item" data-type="{{ $types }}" data-year="{{ $year }}">
      {{- $rawTitle := or .Params.title .Title -}}
      {{- $rendered := replaceRE "^<p>(.*)</p>$" "$1" $rawTitle | htmlEscape -}}
      <a href="{{ .RelPermalink }}"><span><strong>{{- $rendered | safeHTML -}}</strong></span></a><br>

      {{- $authors := .Params.authors -}}
      {{- $editors := .Params.editors -}}
      {{- $isPatent := eq .Params.item_type "patent" -}}
      {{- if or $authors $editors -}}
        {{- if $authors -}}
          {{- if reflect.IsSlice $authors -}}
            {{- if $isPatent }}Inventors: {{ end }}{{ delimit $authors "; " "; and " }}
          {{- else -}}
            {{- if $isPatent }}Inventor: {{ end }}{{ $authors }}
          {{- end -}}
        {{- else -}}
          Edited by: {{ if reflect.IsSlice $editors }}{{ delimit $editors "; " "; and " }}{{ else }}{{ $editors }}{{ end }}
        {{- end -}}
        <br>
      {{- end -}}

      {{- /* format date string for display; don't show bogus */ -}}
      {{- $dstr := $d.Format "2006-01-02" -}}
      {{- if (ne $dstr "0001-01-01") }}
        <time datetime="{{ $dstr }}">{{ $fmtDate }}</time>
      {{ end -}}

      {{ with .Params.abstract -}}
        {{- $plain := . | htmlEscape | replaceRE `\s+` " " -}}
        {{- $previewing := gt (countwords $plain) $previewWordLimit -}}
        {{- $preview := "" -}}
        {{- if $previewing -}}
          {{- $previewWords := split $plain " " | first $previewWordLimit -}}
          {{- $preview = delimit $previewWords " " -}}
        {{- else -}}
          {{- $preview = replace (. | htmlEscape) "\n" "<br>" -}}
        {{- end -}}
        <br>
        <div>{{ $preview | safeHTML }}{{ if $previewing }}â€¦{{ end }}</div>
        <br>
      {{- end -}}
    </li>
  {{ end }}
</ul>

<script>
document.addEventListener('DOMContentLoaded', function () {
  const typeSel = document.getElementById('itemTypeFilter');
  const yearSel = document.getElementById('yearFilter');
  const items = Array.from(document.querySelectorAll('#bibliographyList > li'));

  const getTypes = li => (li.dataset.type || '')
    .split(',').map(s => s.trim().toLowerCase()).filter(Boolean);
  const getYear = li => (li.dataset.year || '').toLowerCase();

  function computeSets(t, y) {
    const cand = items.filter(li =>
      (t === 'all' || getTypes(li).includes(t)) &&
      (y === 'all' || getYear(li) === y)
    );
    const years = new Set();
    const types = new Set();
    cand.forEach(li => {
      years.add(getYear(li));
      getTypes(li).forEach(v => types.add(v));
    });
    years.delete(''); // clean up
    types.delete('');
    return { years, types };
  }

  function updateOptionLists(yearsSet, typesSet) {
    // Year options
    Array.from(yearSel.options).forEach(opt => {
      if (opt.value === 'all') { opt.disabled = false; opt.hidden = false; return; }
      const ok = yearsSet.has(opt.value.toLowerCase());
      opt.disabled = !ok;
      opt.hidden = !ok;
    });
    // Type options
    Array.from(typeSel.options).forEach(opt => {
      if (opt.value === 'all') { opt.disabled = false; opt.hidden = false; return; }
      const ok = typesSet.has(opt.value.toLowerCase());
      opt.disabled = !ok;
      opt.hidden = !ok;
    });
  }

  function showHideItems(t, y) {
    items.forEach(li => {
      const types = getTypes(li);
      const yr = getYear(li);
      const typeOK = (t === 'all') || types.includes(t);
      const yearOK = (y === 'all') || (yr === y);
      li.style.display = (typeOK && yearOK) ? '' : 'none';
    });
  }

  function refresh() {
    let t = (typeSel.value || 'all').toLowerCase();
    let y = (yearSel.value || 'all').toLowerCase();

    // Compute valid sets for current selections
    let sets = computeSets(t, y);

    // If current selection is invalid under the other filter, reset it
    if (y !== 'all' && !sets.years.has(y)) { y = 'all'; yearSel.value = 'all'; }
    if (t !== 'all' && !sets.types.has(t)) { t = 'all'; typeSel.value = 'all'; }

    // Recompute with possibly reset values and update dropdowns
    sets = computeSets(t, y);
    updateOptionLists(sets.years, sets.types);

    // Apply to list
    showHideItems(t, y);
  }

  // Preselect from URL (?item_type=...&year=YYYY|undated)
  const params = new URLSearchParams(window.location.search);
  const qType = (params.get('item_type') || '').toLowerCase();
  if (qType && typeSel.querySelector(`option[value="${qType}"]`)) typeSel.value = qType;
  const qYear = (params.get('year') || '').toLowerCase();
  if (qYear && (qYear === 'undated' || yearSel.querySelector(`option[value="${qYear}"]`))) yearSel.value = qYear;

  typeSel.addEventListener('change', refresh);
  yearSel.addEventListener('change', refresh);
  refresh();
});
</script>

{{ end }}